// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: models.go

package model

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Animation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Animation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(j.FileName))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAnimationbase = iota
	ffjtAnimationnosuchkey

	ffjtAnimationFileID

	ffjtAnimationFileUniqueID

	ffjtAnimationWidth

	ffjtAnimationHeight

	ffjtAnimationDuration

	ffjtAnimationThumb

	ffjtAnimationFileName

	ffjtAnimationMimeType

	ffjtAnimationFileSize
)

var ffjKeyAnimationFileID = []byte("file_id")

var ffjKeyAnimationFileUniqueID = []byte("file_unique_id")

var ffjKeyAnimationWidth = []byte("width")

var ffjKeyAnimationHeight = []byte("height")

var ffjKeyAnimationDuration = []byte("duration")

var ffjKeyAnimationThumb = []byte("thumb")

var ffjKeyAnimationFileName = []byte("file_name")

var ffjKeyAnimationMimeType = []byte("mime_type")

var ffjKeyAnimationFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Animation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Animation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAnimationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAnimationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyAnimationDuration, kn) {
						currentKey = ffjtAnimationDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAnimationFileID, kn) {
						currentKey = ffjtAnimationFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAnimationFileUniqueID, kn) {
						currentKey = ffjtAnimationFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAnimationFileName, kn) {
						currentKey = ffjtAnimationFileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAnimationFileSize, kn) {
						currentKey = ffjtAnimationFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyAnimationHeight, kn) {
						currentKey = ffjtAnimationHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAnimationMimeType, kn) {
						currentKey = ffjtAnimationMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAnimationThumb, kn) {
						currentKey = ffjtAnimationThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyAnimationWidth, kn) {
						currentKey = ffjtAnimationWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAnimationFileSize, kn) {
					currentKey = ffjtAnimationFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAnimationMimeType, kn) {
					currentKey = ffjtAnimationMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAnimationFileName, kn) {
					currentKey = ffjtAnimationFileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAnimationThumb, kn) {
					currentKey = ffjtAnimationThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAnimationDuration, kn) {
					currentKey = ffjtAnimationDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAnimationHeight, kn) {
					currentKey = ffjtAnimationHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAnimationWidth, kn) {
					currentKey = ffjtAnimationWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAnimationFileUniqueID, kn) {
					currentKey = ffjtAnimationFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAnimationFileID, kn) {
					currentKey = ffjtAnimationFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAnimationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAnimationFileID:
					goto handle_FileID

				case ffjtAnimationFileUniqueID:
					goto handle_FileUniqueID

				case ffjtAnimationWidth:
					goto handle_Width

				case ffjtAnimationHeight:
					goto handle_Height

				case ffjtAnimationDuration:
					goto handle_Duration

				case ffjtAnimationThumb:
					goto handle_Thumb

				case ffjtAnimationFileName:
					goto handle_FileName

				case ffjtAnimationMimeType:
					goto handle_MimeType

				case ffjtAnimationFileSize:
					goto handle_FileSize

				case ffjtAnimationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=model.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: j.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Audio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Audio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if len(j.Performer) != 0 {
		buf.WriteString(`"performer":`)
		fflib.WriteJsonString(buf, string(j.Performer))
		buf.WriteByte(',')
	}
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(j.FileName))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAudiobase = iota
	ffjtAudionosuchkey

	ffjtAudioFileID

	ffjtAudioFileUniqueID

	ffjtAudioDuration

	ffjtAudioPerformer

	ffjtAudioTitle

	ffjtAudioFileName

	ffjtAudioMimeType

	ffjtAudioFileSize

	ffjtAudioThumb
)

var ffjKeyAudioFileID = []byte("file_id")

var ffjKeyAudioFileUniqueID = []byte("file_unique_id")

var ffjKeyAudioDuration = []byte("duration")

var ffjKeyAudioPerformer = []byte("performer")

var ffjKeyAudioTitle = []byte("title")

var ffjKeyAudioFileName = []byte("file_name")

var ffjKeyAudioMimeType = []byte("mime_type")

var ffjKeyAudioFileSize = []byte("file_size")

var ffjKeyAudioThumb = []byte("thumb")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Audio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Audio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyAudioDuration, kn) {
						currentKey = ffjtAudioDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAudioFileID, kn) {
						currentKey = ffjtAudioFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAudioFileUniqueID, kn) {
						currentKey = ffjtAudioFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAudioFileName, kn) {
						currentKey = ffjtAudioFileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAudioFileSize, kn) {
						currentKey = ffjtAudioFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAudioMimeType, kn) {
						currentKey = ffjtAudioMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAudioPerformer, kn) {
						currentKey = ffjtAudioPerformer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAudioTitle, kn) {
						currentKey = ffjtAudioTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAudioThumb, kn) {
						currentKey = ffjtAudioThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioThumb, kn) {
					currentKey = ffjtAudioThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAudioFileSize, kn) {
					currentKey = ffjtAudioFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioMimeType, kn) {
					currentKey = ffjtAudioMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioFileName, kn) {
					currentKey = ffjtAudioFileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioTitle, kn) {
					currentKey = ffjtAudioTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioPerformer, kn) {
					currentKey = ffjtAudioPerformer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioDuration, kn) {
					currentKey = ffjtAudioDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioFileUniqueID, kn) {
					currentKey = ffjtAudioFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioFileID, kn) {
					currentKey = ffjtAudioFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAudioFileID:
					goto handle_FileID

				case ffjtAudioFileUniqueID:
					goto handle_FileUniqueID

				case ffjtAudioDuration:
					goto handle_Duration

				case ffjtAudioPerformer:
					goto handle_Performer

				case ffjtAudioTitle:
					goto handle_Title

				case ffjtAudioFileName:
					goto handle_FileName

				case ffjtAudioMimeType:
					goto handle_MimeType

				case ffjtAudioFileSize:
					goto handle_FileSize

				case ffjtAudioThumb:
					goto handle_Thumb

				case ffjtAudionosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: j.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: j.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=model.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CallbackGame) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CallbackGame) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffjtCallbackGamebase = iota
	ffjtCallbackGamenosuchkey
)

// UnmarshalJSON umarshall json - template of ffjson
func (j *CallbackGame) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CallbackGame) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCallbackGamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCallbackGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffjtCallbackGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCallbackGamenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CallbackQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CallbackQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteByte(',')
	if j.Message != nil {
		if true {
			buf.WriteString(`"message":`)

			{

				err = j.Message.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.InlineMessageID) != 0 {
		buf.WriteString(`"inline_message_id":`)
		fflib.WriteJsonString(buf, string(j.InlineMessageID))
		buf.WriteByte(',')
	}
	if len(j.ChatInstance) != 0 {
		buf.WriteString(`"chat_instance":`)
		fflib.WriteJsonString(buf, string(j.ChatInstance))
		buf.WriteByte(',')
	}
	if len(j.Data) != 0 {
		buf.WriteString(`"data":`)
		fflib.WriteJsonString(buf, string(j.Data))
		buf.WriteByte(',')
	}
	if len(j.GameShortName) != 0 {
		buf.WriteString(`"game_short_name":`)
		fflib.WriteJsonString(buf, string(j.GameShortName))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCallbackQuerybase = iota
	ffjtCallbackQuerynosuchkey

	ffjtCallbackQueryID

	ffjtCallbackQueryFrom

	ffjtCallbackQueryMessage

	ffjtCallbackQueryInlineMessageID

	ffjtCallbackQueryChatInstance

	ffjtCallbackQueryData

	ffjtCallbackQueryGameShortName
)

var ffjKeyCallbackQueryID = []byte("id")

var ffjKeyCallbackQueryFrom = []byte("from")

var ffjKeyCallbackQueryMessage = []byte("message")

var ffjKeyCallbackQueryInlineMessageID = []byte("inline_message_id")

var ffjKeyCallbackQueryChatInstance = []byte("chat_instance")

var ffjKeyCallbackQueryData = []byte("data")

var ffjKeyCallbackQueryGameShortName = []byte("game_short_name")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CallbackQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CallbackQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCallbackQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCallbackQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyCallbackQueryChatInstance, kn) {
						currentKey = ffjtCallbackQueryChatInstance
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyCallbackQueryData, kn) {
						currentKey = ffjtCallbackQueryData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyCallbackQueryFrom, kn) {
						currentKey = ffjtCallbackQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyCallbackQueryGameShortName, kn) {
						currentKey = ffjtCallbackQueryGameShortName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyCallbackQueryID, kn) {
						currentKey = ffjtCallbackQueryID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyCallbackQueryInlineMessageID, kn) {
						currentKey = ffjtCallbackQueryInlineMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyCallbackQueryMessage, kn) {
						currentKey = ffjtCallbackQueryMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryGameShortName, kn) {
					currentKey = ffjtCallbackQueryGameShortName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCallbackQueryData, kn) {
					currentKey = ffjtCallbackQueryData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryChatInstance, kn) {
					currentKey = ffjtCallbackQueryChatInstance
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryInlineMessageID, kn) {
					currentKey = ffjtCallbackQueryInlineMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyCallbackQueryMessage, kn) {
					currentKey = ffjtCallbackQueryMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCallbackQueryFrom, kn) {
					currentKey = ffjtCallbackQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyCallbackQueryID, kn) {
					currentKey = ffjtCallbackQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCallbackQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCallbackQueryID:
					goto handle_ID

				case ffjtCallbackQueryFrom:
					goto handle_From

				case ffjtCallbackQueryMessage:
					goto handle_Message

				case ffjtCallbackQueryInlineMessageID:
					goto handle_InlineMessageID

				case ffjtCallbackQueryChatInstance:
					goto handle_ChatInstance

				case ffjtCallbackQueryData:
					goto handle_Data

				case ffjtCallbackQueryGameShortName:
					goto handle_GameShortName

				case ffjtCallbackQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Message = nil

		} else {

			if j.Message == nil {
				j.Message = new(Message)
			}

			err = j.Message.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineMessageID:

	/* handler: j.InlineMessageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InlineMessageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatInstance:

	/* handler: j.ChatInstance type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ChatInstance = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: j.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GameShortName:

	/* handler: j.GameShortName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GameShortName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Chat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Chat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if len(j.Username) != 0 {
		buf.WriteString(`"username":`)
		fflib.WriteJsonString(buf, string(j.Username))
		buf.WriteByte(',')
	}
	if len(j.FirstName) != 0 {
		buf.WriteString(`"first_name":`)
		fflib.WriteJsonString(buf, string(j.FirstName))
		buf.WriteByte(',')
	}
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if j.Photo != nil {
		if true {
			buf.WriteString(`"photo":`)

			{

				err = j.Photo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Bio) != 0 {
		buf.WriteString(`"bio":`)
		fflib.WriteJsonString(buf, string(j.Bio))
		buf.WriteByte(',')
	}
	if j.HasPrivateForwards != false {
		if j.HasPrivateForwards {
			buf.WriteString(`"has_private_forwards":true`)
		} else {
			buf.WriteString(`"has_private_forwards":false`)
		}
		buf.WriteByte(',')
	}
	if j.HasRestrictedVoiceAndVideoMessages != false {
		if j.HasRestrictedVoiceAndVideoMessages {
			buf.WriteString(`"has_restricted_voice_and_video_messages":true`)
		} else {
			buf.WriteString(`"has_restricted_voice_and_video_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.JoinToSendMessages != false {
		if j.JoinToSendMessages {
			buf.WriteString(`"join_to_send_messages":true`)
		} else {
			buf.WriteString(`"join_to_send_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.JoinByRequest != false {
		if j.JoinByRequest {
			buf.WriteString(`"join_by_request":true`)
		} else {
			buf.WriteString(`"join_by_request":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.InviteLink) != 0 {
		buf.WriteString(`"invite_link":`)
		fflib.WriteJsonString(buf, string(j.InviteLink))
		buf.WriteByte(',')
	}
	if j.PinnedMessage != nil {
		if true {
			buf.WriteString(`"pinned_message":`)

			{

				err = j.PinnedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Permissions != nil {
		if true {
			buf.WriteString(`"permissions":`)

			{

				err = j.Permissions.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.SlowModeDelay != 0 {
		buf.WriteString(`"slow_mode_delay":`)
		fflib.FormatBits2(buf, uint64(j.SlowModeDelay), 10, j.SlowModeDelay < 0)
		buf.WriteByte(',')
	}
	if j.MessageAutoDeleteTime != 0 {
		buf.WriteString(`"message_auto_delete_time":`)
		fflib.FormatBits2(buf, uint64(j.MessageAutoDeleteTime), 10, j.MessageAutoDeleteTime < 0)
		buf.WriteByte(',')
	}
	if j.HasProtectedContent != false {
		if j.HasProtectedContent {
			buf.WriteString(`"has_protected_content":true`)
		} else {
			buf.WriteString(`"has_protected_content":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.StickerSetName) != 0 {
		buf.WriteString(`"sticker_set_name":`)
		fflib.WriteJsonString(buf, string(j.StickerSetName))
		buf.WriteByte(',')
	}
	if j.CanSetStickerSet != false {
		if j.CanSetStickerSet {
			buf.WriteString(`"can_set_sticker_set":true`)
		} else {
			buf.WriteString(`"can_set_sticker_set":false`)
		}
		buf.WriteByte(',')
	}
	if j.LinkedChatID != 0 {
		buf.WriteString(`"linked_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.LinkedChatID), 10, j.LinkedChatID < 0)
		buf.WriteByte(',')
	}
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatbase = iota
	ffjtChatnosuchkey

	ffjtChatID

	ffjtChatType

	ffjtChatTitle

	ffjtChatUsername

	ffjtChatFirstName

	ffjtChatLastName

	ffjtChatPhoto

	ffjtChatBio

	ffjtChatHasPrivateForwards

	ffjtChatHasRestrictedVoiceAndVideoMessages

	ffjtChatJoinToSendMessages

	ffjtChatJoinByRequest

	ffjtChatDescription

	ffjtChatInviteLink

	ffjtChatPinnedMessage

	ffjtChatPermissions

	ffjtChatSlowModeDelay

	ffjtChatMessageAutoDeleteTime

	ffjtChatHasProtectedContent

	ffjtChatStickerSetName

	ffjtChatCanSetStickerSet

	ffjtChatLinkedChatID

	ffjtChatLocation
)

var ffjKeyChatID = []byte("id")

var ffjKeyChatType = []byte("type")

var ffjKeyChatTitle = []byte("title")

var ffjKeyChatUsername = []byte("username")

var ffjKeyChatFirstName = []byte("first_name")

var ffjKeyChatLastName = []byte("last_name")

var ffjKeyChatPhoto = []byte("photo")

var ffjKeyChatBio = []byte("bio")

var ffjKeyChatHasPrivateForwards = []byte("has_private_forwards")

var ffjKeyChatHasRestrictedVoiceAndVideoMessages = []byte("has_restricted_voice_and_video_messages")

var ffjKeyChatJoinToSendMessages = []byte("join_to_send_messages")

var ffjKeyChatJoinByRequest = []byte("join_by_request")

var ffjKeyChatDescription = []byte("description")

var ffjKeyChatInviteLink = []byte("invite_link")

var ffjKeyChatPinnedMessage = []byte("pinned_message")

var ffjKeyChatPermissions = []byte("permissions")

var ffjKeyChatSlowModeDelay = []byte("slow_mode_delay")

var ffjKeyChatMessageAutoDeleteTime = []byte("message_auto_delete_time")

var ffjKeyChatHasProtectedContent = []byte("has_protected_content")

var ffjKeyChatStickerSetName = []byte("sticker_set_name")

var ffjKeyChatCanSetStickerSet = []byte("can_set_sticker_set")

var ffjKeyChatLinkedChatID = []byte("linked_chat_id")

var ffjKeyChatLocation = []byte("location")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Chat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Chat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyChatBio, kn) {
						currentKey = ffjtChatBio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChatCanSetStickerSet, kn) {
						currentKey = ffjtChatCanSetStickerSet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChatDescription, kn) {
						currentKey = ffjtChatDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyChatFirstName, kn) {
						currentKey = ffjtChatFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyChatHasPrivateForwards, kn) {
						currentKey = ffjtChatHasPrivateForwards
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatHasRestrictedVoiceAndVideoMessages, kn) {
						currentKey = ffjtChatHasRestrictedVoiceAndVideoMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatHasProtectedContent, kn) {
						currentKey = ffjtChatHasProtectedContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatID, kn) {
						currentKey = ffjtChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatInviteLink, kn) {
						currentKey = ffjtChatInviteLink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'j':

					if bytes.Equal(ffjKeyChatJoinToSendMessages, kn) {
						currentKey = ffjtChatJoinToSendMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatJoinByRequest, kn) {
						currentKey = ffjtChatJoinByRequest
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChatLastName, kn) {
						currentKey = ffjtChatLastName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatLinkedChatID, kn) {
						currentKey = ffjtChatLinkedChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatLocation, kn) {
						currentKey = ffjtChatLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChatMessageAutoDeleteTime, kn) {
						currentKey = ffjtChatMessageAutoDeleteTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyChatPhoto, kn) {
						currentKey = ffjtChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPinnedMessage, kn) {
						currentKey = ffjtChatPinnedMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissions, kn) {
						currentKey = ffjtChatPermissions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatSlowModeDelay, kn) {
						currentKey = ffjtChatSlowModeDelay
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatStickerSetName, kn) {
						currentKey = ffjtChatStickerSetName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChatType, kn) {
						currentKey = ffjtChatType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatTitle, kn) {
						currentKey = ffjtChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatUsername, kn) {
						currentKey = ffjtChatUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatLocation, kn) {
					currentKey = ffjtChatLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatLinkedChatID, kn) {
					currentKey = ffjtChatLinkedChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatCanSetStickerSet, kn) {
					currentKey = ffjtChatCanSetStickerSet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatStickerSetName, kn) {
					currentKey = ffjtChatStickerSetName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatHasProtectedContent, kn) {
					currentKey = ffjtChatHasProtectedContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMessageAutoDeleteTime, kn) {
					currentKey = ffjtChatMessageAutoDeleteTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatSlowModeDelay, kn) {
					currentKey = ffjtChatSlowModeDelay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPermissions, kn) {
					currentKey = ffjtChatPermissions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPinnedMessage, kn) {
					currentKey = ffjtChatPinnedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatInviteLink, kn) {
					currentKey = ffjtChatInviteLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatDescription, kn) {
					currentKey = ffjtChatDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatJoinByRequest, kn) {
					currentKey = ffjtChatJoinByRequest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatJoinToSendMessages, kn) {
					currentKey = ffjtChatJoinToSendMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatHasRestrictedVoiceAndVideoMessages, kn) {
					currentKey = ffjtChatHasRestrictedVoiceAndVideoMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatHasPrivateForwards, kn) {
					currentKey = ffjtChatHasPrivateForwards
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatBio, kn) {
					currentKey = ffjtChatBio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatPhoto, kn) {
					currentKey = ffjtChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatLastName, kn) {
					currentKey = ffjtChatLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatFirstName, kn) {
					currentKey = ffjtChatFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatUsername, kn) {
					currentKey = ffjtChatUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatTitle, kn) {
					currentKey = ffjtChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatType, kn) {
					currentKey = ffjtChatType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatID, kn) {
					currentKey = ffjtChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatID:
					goto handle_ID

				case ffjtChatType:
					goto handle_Type

				case ffjtChatTitle:
					goto handle_Title

				case ffjtChatUsername:
					goto handle_Username

				case ffjtChatFirstName:
					goto handle_FirstName

				case ffjtChatLastName:
					goto handle_LastName

				case ffjtChatPhoto:
					goto handle_Photo

				case ffjtChatBio:
					goto handle_Bio

				case ffjtChatHasPrivateForwards:
					goto handle_HasPrivateForwards

				case ffjtChatHasRestrictedVoiceAndVideoMessages:
					goto handle_HasRestrictedVoiceAndVideoMessages

				case ffjtChatJoinToSendMessages:
					goto handle_JoinToSendMessages

				case ffjtChatJoinByRequest:
					goto handle_JoinByRequest

				case ffjtChatDescription:
					goto handle_Description

				case ffjtChatInviteLink:
					goto handle_InviteLink

				case ffjtChatPinnedMessage:
					goto handle_PinnedMessage

				case ffjtChatPermissions:
					goto handle_Permissions

				case ffjtChatSlowModeDelay:
					goto handle_SlowModeDelay

				case ffjtChatMessageAutoDeleteTime:
					goto handle_MessageAutoDeleteTime

				case ffjtChatHasProtectedContent:
					goto handle_HasProtectedContent

				case ffjtChatStickerSetName:
					goto handle_StickerSetName

				case ffjtChatCanSetStickerSet:
					goto handle_CanSetStickerSet

				case ffjtChatLinkedChatID:
					goto handle_LinkedChatID

				case ffjtChatLocation:
					goto handle_Location

				case ffjtChatnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: j.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=model.ChatPhoto kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Photo = nil

		} else {

			if j.Photo == nil {
				j.Photo = new(ChatPhoto)
			}

			err = j.Photo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bio:

	/* handler: j.Bio type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bio = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HasPrivateForwards:

	/* handler: j.HasPrivateForwards type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HasPrivateForwards = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HasPrivateForwards = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HasRestrictedVoiceAndVideoMessages:

	/* handler: j.HasRestrictedVoiceAndVideoMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HasRestrictedVoiceAndVideoMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HasRestrictedVoiceAndVideoMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_JoinToSendMessages:

	/* handler: j.JoinToSendMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.JoinToSendMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.JoinToSendMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_JoinByRequest:

	/* handler: j.JoinByRequest type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.JoinByRequest = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.JoinByRequest = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InviteLink:

	/* handler: j.InviteLink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InviteLink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PinnedMessage:

	/* handler: j.PinnedMessage type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PinnedMessage = nil

		} else {

			if j.PinnedMessage == nil {
				j.PinnedMessage = new(Message)
			}

			err = j.PinnedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Permissions:

	/* handler: j.Permissions type=model.ChatPermissions kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Permissions = nil

		} else {

			if j.Permissions == nil {
				j.Permissions = new(ChatPermissions)
			}

			err = j.Permissions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SlowModeDelay:

	/* handler: j.SlowModeDelay type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SlowModeDelay = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageAutoDeleteTime:

	/* handler: j.MessageAutoDeleteTime type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MessageAutoDeleteTime = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HasProtectedContent:

	/* handler: j.HasProtectedContent type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HasProtectedContent = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HasProtectedContent = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StickerSetName:

	/* handler: j.StickerSetName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StickerSetName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSetStickerSet:

	/* handler: j.CanSetStickerSet type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSetStickerSet = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSetStickerSet = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LinkedChatID:

	/* handler: j.LinkedChatID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LinkedChatID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=model.ChatLocation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(ChatLocation)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatInviteLink) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatInviteLink) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "invite_link":`)
	fflib.WriteJsonString(buf, string(j.InviteLink))
	if j.Creator != nil {
		buf.WriteString(`,"creator":`)

		{

			err = j.Creator.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"creator":null`)
	}
	if j.CreatesJoinRequest {
		buf.WriteString(`,"creates_join_request":true`)
	} else {
		buf.WriteString(`,"creates_join_request":false`)
	}
	if j.IsPrimary {
		buf.WriteString(`,"is_primary":true`)
	} else {
		buf.WriteString(`,"is_primary":false`)
	}
	if j.IsRevoked {
		buf.WriteString(`,"is_revoked":true`)
	} else {
		buf.WriteString(`,"is_revoked":false`)
	}
	buf.WriteByte(',')
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if j.ExpireDate != 0 {
		buf.WriteString(`"expire_date":`)
		fflib.FormatBits2(buf, uint64(j.ExpireDate), 10, j.ExpireDate < 0)
		buf.WriteByte(',')
	}
	if j.MemberLimit != 0 {
		buf.WriteString(`"member_limit":`)
		fflib.FormatBits2(buf, uint64(j.MemberLimit), 10, j.MemberLimit < 0)
		buf.WriteByte(',')
	}
	if j.PendingJoinRequestCount != 0 {
		buf.WriteString(`"pending_join_request_count":`)
		fflib.FormatBits2(buf, uint64(j.PendingJoinRequestCount), 10, j.PendingJoinRequestCount < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatInviteLinkbase = iota
	ffjtChatInviteLinknosuchkey

	ffjtChatInviteLinkInviteLink

	ffjtChatInviteLinkCreator

	ffjtChatInviteLinkCreatesJoinRequest

	ffjtChatInviteLinkIsPrimary

	ffjtChatInviteLinkIsRevoked

	ffjtChatInviteLinkName

	ffjtChatInviteLinkExpireDate

	ffjtChatInviteLinkMemberLimit

	ffjtChatInviteLinkPendingJoinRequestCount
)

var ffjKeyChatInviteLinkInviteLink = []byte("invite_link")

var ffjKeyChatInviteLinkCreator = []byte("creator")

var ffjKeyChatInviteLinkCreatesJoinRequest = []byte("creates_join_request")

var ffjKeyChatInviteLinkIsPrimary = []byte("is_primary")

var ffjKeyChatInviteLinkIsRevoked = []byte("is_revoked")

var ffjKeyChatInviteLinkName = []byte("name")

var ffjKeyChatInviteLinkExpireDate = []byte("expire_date")

var ffjKeyChatInviteLinkMemberLimit = []byte("member_limit")

var ffjKeyChatInviteLinkPendingJoinRequestCount = []byte("pending_join_request_count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatInviteLink) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatInviteLink) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatInviteLinkbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatInviteLinknosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChatInviteLinkCreator, kn) {
						currentKey = ffjtChatInviteLinkCreator
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatInviteLinkCreatesJoinRequest, kn) {
						currentKey = ffjtChatInviteLinkCreatesJoinRequest
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyChatInviteLinkExpireDate, kn) {
						currentKey = ffjtChatInviteLinkExpireDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatInviteLinkInviteLink, kn) {
						currentKey = ffjtChatInviteLinkInviteLink
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatInviteLinkIsPrimary, kn) {
						currentKey = ffjtChatInviteLinkIsPrimary
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatInviteLinkIsRevoked, kn) {
						currentKey = ffjtChatInviteLinkIsRevoked
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChatInviteLinkMemberLimit, kn) {
						currentKey = ffjtChatInviteLinkMemberLimit
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyChatInviteLinkName, kn) {
						currentKey = ffjtChatInviteLinkName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyChatInviteLinkPendingJoinRequestCount, kn) {
						currentKey = ffjtChatInviteLinkPendingJoinRequestCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatInviteLinkPendingJoinRequestCount, kn) {
					currentKey = ffjtChatInviteLinkPendingJoinRequestCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatInviteLinkMemberLimit, kn) {
					currentKey = ffjtChatInviteLinkMemberLimit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatInviteLinkExpireDate, kn) {
					currentKey = ffjtChatInviteLinkExpireDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatInviteLinkName, kn) {
					currentKey = ffjtChatInviteLinkName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatInviteLinkIsRevoked, kn) {
					currentKey = ffjtChatInviteLinkIsRevoked
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatInviteLinkIsPrimary, kn) {
					currentKey = ffjtChatInviteLinkIsPrimary
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatInviteLinkCreatesJoinRequest, kn) {
					currentKey = ffjtChatInviteLinkCreatesJoinRequest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatInviteLinkCreator, kn) {
					currentKey = ffjtChatInviteLinkCreator
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatInviteLinkInviteLink, kn) {
					currentKey = ffjtChatInviteLinkInviteLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatInviteLinknosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatInviteLinkInviteLink:
					goto handle_InviteLink

				case ffjtChatInviteLinkCreator:
					goto handle_Creator

				case ffjtChatInviteLinkCreatesJoinRequest:
					goto handle_CreatesJoinRequest

				case ffjtChatInviteLinkIsPrimary:
					goto handle_IsPrimary

				case ffjtChatInviteLinkIsRevoked:
					goto handle_IsRevoked

				case ffjtChatInviteLinkName:
					goto handle_Name

				case ffjtChatInviteLinkExpireDate:
					goto handle_ExpireDate

				case ffjtChatInviteLinkMemberLimit:
					goto handle_MemberLimit

				case ffjtChatInviteLinkPendingJoinRequestCount:
					goto handle_PendingJoinRequestCount

				case ffjtChatInviteLinknosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InviteLink:

	/* handler: j.InviteLink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InviteLink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Creator:

	/* handler: j.Creator type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Creator = nil

		} else {

			if j.Creator == nil {
				j.Creator = new(User)
			}

			err = j.Creator.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatesJoinRequest:

	/* handler: j.CreatesJoinRequest type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CreatesJoinRequest = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CreatesJoinRequest = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsPrimary:

	/* handler: j.IsPrimary type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsPrimary = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsPrimary = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsRevoked:

	/* handler: j.IsRevoked type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsRevoked = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsRevoked = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExpireDate:

	/* handler: j.ExpireDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExpireDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemberLimit:

	/* handler: j.MemberLimit type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MemberLimit = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PendingJoinRequestCount:

	/* handler: j.PendingJoinRequestCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PendingJoinRequestCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatJoinRequest) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatJoinRequest) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Chat != nil {
		buf.WriteString(`{ "chat":`)

		{

			err = j.Chat.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{ "chat":null`)
	}
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteString(`,"date":`)
	fflib.FormatBits2(buf, uint64(j.Date), 10, j.Date < 0)
	buf.WriteByte(',')
	if len(j.Bio) != 0 {
		buf.WriteString(`"bio":`)
		fflib.WriteJsonString(buf, string(j.Bio))
		buf.WriteByte(',')
	}
	if j.InviteLink != nil {
		if true {
			buf.WriteString(`"invite_link":`)

			{

				err = j.InviteLink.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatJoinRequestbase = iota
	ffjtChatJoinRequestnosuchkey

	ffjtChatJoinRequestChat

	ffjtChatJoinRequestFrom

	ffjtChatJoinRequestDate

	ffjtChatJoinRequestBio

	ffjtChatJoinRequestInviteLink
)

var ffjKeyChatJoinRequestChat = []byte("chat")

var ffjKeyChatJoinRequestFrom = []byte("from")

var ffjKeyChatJoinRequestDate = []byte("date")

var ffjKeyChatJoinRequestBio = []byte("bio")

var ffjKeyChatJoinRequestInviteLink = []byte("invite_link")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatJoinRequest) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatJoinRequest) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatJoinRequestbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatJoinRequestnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyChatJoinRequestBio, kn) {
						currentKey = ffjtChatJoinRequestBio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChatJoinRequestChat, kn) {
						currentKey = ffjtChatJoinRequestChat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChatJoinRequestDate, kn) {
						currentKey = ffjtChatJoinRequestDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyChatJoinRequestFrom, kn) {
						currentKey = ffjtChatJoinRequestFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatJoinRequestInviteLink, kn) {
						currentKey = ffjtChatJoinRequestInviteLink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatJoinRequestInviteLink, kn) {
					currentKey = ffjtChatJoinRequestInviteLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatJoinRequestBio, kn) {
					currentKey = ffjtChatJoinRequestBio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatJoinRequestDate, kn) {
					currentKey = ffjtChatJoinRequestDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatJoinRequestFrom, kn) {
					currentKey = ffjtChatJoinRequestFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatJoinRequestChat, kn) {
					currentKey = ffjtChatJoinRequestChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatJoinRequestnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatJoinRequestChat:
					goto handle_Chat

				case ffjtChatJoinRequestFrom:
					goto handle_From

				case ffjtChatJoinRequestDate:
					goto handle_Date

				case ffjtChatJoinRequestBio:
					goto handle_Bio

				case ffjtChatJoinRequestInviteLink:
					goto handle_InviteLink

				case ffjtChatJoinRequestnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Chat:

	/* handler: j.Chat type=model.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Chat = nil

		} else {

			if j.Chat == nil {
				j.Chat = new(Chat)
			}

			err = j.Chat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: j.Date type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Date = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bio:

	/* handler: j.Bio type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bio = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InviteLink:

	/* handler: j.InviteLink type=model.ChatInviteLink kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.InviteLink = nil

		} else {

			if j.InviteLink == nil {
				j.InviteLink = new(ChatInviteLink)
			}

			err = j.InviteLink.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatLocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatLocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Location != nil {
		buf.WriteString(`{"location":`)

		{

			err = j.Location.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{"location":null`)
	}
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatLocationbase = iota
	ffjtChatLocationnosuchkey

	ffjtChatLocationLocation

	ffjtChatLocationAddress
)

var ffjKeyChatLocationLocation = []byte("location")

var ffjKeyChatLocationAddress = []byte("address")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatLocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatLocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChatLocationAddress, kn) {
						currentKey = ffjtChatLocationAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChatLocationLocation, kn) {
						currentKey = ffjtChatLocationLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatLocationAddress, kn) {
					currentKey = ffjtChatLocationAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatLocationLocation, kn) {
					currentKey = ffjtChatLocationLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatLocationLocation:
					goto handle_Location

				case ffjtChatLocationAddress:
					goto handle_Address

				case ffjtChatLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Location:

	/* handler: j.Location type=model.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMemberAdministrator) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMemberAdministrator) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	if j.CanBeEdited {
		buf.WriteString(`,"can_be_edited":true`)
	} else {
		buf.WriteString(`,"can_be_edited":false`)
	}
	if j.IsAnonymous {
		buf.WriteString(`,"is_anonymous":true`)
	} else {
		buf.WriteString(`,"is_anonymous":false`)
	}
	if j.CanManageChat {
		buf.WriteString(`,"can_manage_chat":true`)
	} else {
		buf.WriteString(`,"can_manage_chat":false`)
	}
	if j.CanDeleteMessages {
		buf.WriteString(`,"can_delete_messages":true`)
	} else {
		buf.WriteString(`,"can_delete_messages":false`)
	}
	if j.CanManageVideoChats {
		buf.WriteString(`,"can_manage_video_chats":true`)
	} else {
		buf.WriteString(`,"can_manage_video_chats":false`)
	}
	if j.CanRestrictMembers {
		buf.WriteString(`,"can_restrict_members":true`)
	} else {
		buf.WriteString(`,"can_restrict_members":false`)
	}
	if j.CanPromoteMembers {
		buf.WriteString(`,"can_promote_members":true`)
	} else {
		buf.WriteString(`,"can_promote_members":false`)
	}
	if j.CanChangeInfo {
		buf.WriteString(`,"can_change_info":true`)
	} else {
		buf.WriteString(`,"can_change_info":false`)
	}
	if j.CanInviteUsers {
		buf.WriteString(`,"can_invite_users":true`)
	} else {
		buf.WriteString(`,"can_invite_users":false`)
	}
	buf.WriteByte(',')
	if j.CanPostMessages != false {
		if j.CanPostMessages {
			buf.WriteString(`"can_post_messages":true`)
		} else {
			buf.WriteString(`"can_post_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanEditMessages != false {
		if j.CanEditMessages {
			buf.WriteString(`"can_edit_messages":true`)
		} else {
			buf.WriteString(`"can_edit_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanPinMessages != false {
		if j.CanPinMessages {
			buf.WriteString(`"can_pin_messages":true`)
		} else {
			buf.WriteString(`"can_pin_messages":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.CustomTitle) != 0 {
		buf.WriteString(`"custom_title":`)
		fflib.WriteJsonString(buf, string(j.CustomTitle))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberAdministratorbase = iota
	ffjtChatMemberAdministratornosuchkey

	ffjtChatMemberAdministratorStatus

	ffjtChatMemberAdministratorUser

	ffjtChatMemberAdministratorCanBeEdited

	ffjtChatMemberAdministratorIsAnonymous

	ffjtChatMemberAdministratorCanManageChat

	ffjtChatMemberAdministratorCanDeleteMessages

	ffjtChatMemberAdministratorCanManageVideoChats

	ffjtChatMemberAdministratorCanRestrictMembers

	ffjtChatMemberAdministratorCanPromoteMembers

	ffjtChatMemberAdministratorCanChangeInfo

	ffjtChatMemberAdministratorCanInviteUsers

	ffjtChatMemberAdministratorCanPostMessages

	ffjtChatMemberAdministratorCanEditMessages

	ffjtChatMemberAdministratorCanPinMessages

	ffjtChatMemberAdministratorCustomTitle
)

var ffjKeyChatMemberAdministratorStatus = []byte("status")

var ffjKeyChatMemberAdministratorUser = []byte("user")

var ffjKeyChatMemberAdministratorCanBeEdited = []byte("can_be_edited")

var ffjKeyChatMemberAdministratorIsAnonymous = []byte("is_anonymous")

var ffjKeyChatMemberAdministratorCanManageChat = []byte("can_manage_chat")

var ffjKeyChatMemberAdministratorCanDeleteMessages = []byte("can_delete_messages")

var ffjKeyChatMemberAdministratorCanManageVideoChats = []byte("can_manage_video_chats")

var ffjKeyChatMemberAdministratorCanRestrictMembers = []byte("can_restrict_members")

var ffjKeyChatMemberAdministratorCanPromoteMembers = []byte("can_promote_members")

var ffjKeyChatMemberAdministratorCanChangeInfo = []byte("can_change_info")

var ffjKeyChatMemberAdministratorCanInviteUsers = []byte("can_invite_users")

var ffjKeyChatMemberAdministratorCanPostMessages = []byte("can_post_messages")

var ffjKeyChatMemberAdministratorCanEditMessages = []byte("can_edit_messages")

var ffjKeyChatMemberAdministratorCanPinMessages = []byte("can_pin_messages")

var ffjKeyChatMemberAdministratorCustomTitle = []byte("custom_title")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMemberAdministrator) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMemberAdministrator) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberAdministratorbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMemberAdministratornosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChatMemberAdministratorCanBeEdited, kn) {
						currentKey = ffjtChatMemberAdministratorCanBeEdited
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanManageChat, kn) {
						currentKey = ffjtChatMemberAdministratorCanManageChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanDeleteMessages, kn) {
						currentKey = ffjtChatMemberAdministratorCanDeleteMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanManageVideoChats, kn) {
						currentKey = ffjtChatMemberAdministratorCanManageVideoChats
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanRestrictMembers, kn) {
						currentKey = ffjtChatMemberAdministratorCanRestrictMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanPromoteMembers, kn) {
						currentKey = ffjtChatMemberAdministratorCanPromoteMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanChangeInfo, kn) {
						currentKey = ffjtChatMemberAdministratorCanChangeInfo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanInviteUsers, kn) {
						currentKey = ffjtChatMemberAdministratorCanInviteUsers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanPostMessages, kn) {
						currentKey = ffjtChatMemberAdministratorCanPostMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanEditMessages, kn) {
						currentKey = ffjtChatMemberAdministratorCanEditMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCanPinMessages, kn) {
						currentKey = ffjtChatMemberAdministratorCanPinMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberAdministratorCustomTitle, kn) {
						currentKey = ffjtChatMemberAdministratorCustomTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatMemberAdministratorIsAnonymous, kn) {
						currentKey = ffjtChatMemberAdministratorIsAnonymous
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatMemberAdministratorStatus, kn) {
						currentKey = ffjtChatMemberAdministratorStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberAdministratorUser, kn) {
						currentKey = ffjtChatMemberAdministratorUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCustomTitle, kn) {
					currentKey = ffjtChatMemberAdministratorCustomTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanPinMessages, kn) {
					currentKey = ffjtChatMemberAdministratorCanPinMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanEditMessages, kn) {
					currentKey = ffjtChatMemberAdministratorCanEditMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanPostMessages, kn) {
					currentKey = ffjtChatMemberAdministratorCanPostMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanInviteUsers, kn) {
					currentKey = ffjtChatMemberAdministratorCanInviteUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberAdministratorCanChangeInfo, kn) {
					currentKey = ffjtChatMemberAdministratorCanChangeInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanPromoteMembers, kn) {
					currentKey = ffjtChatMemberAdministratorCanPromoteMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanRestrictMembers, kn) {
					currentKey = ffjtChatMemberAdministratorCanRestrictMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanManageVideoChats, kn) {
					currentKey = ffjtChatMemberAdministratorCanManageVideoChats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorCanDeleteMessages, kn) {
					currentKey = ffjtChatMemberAdministratorCanDeleteMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberAdministratorCanManageChat, kn) {
					currentKey = ffjtChatMemberAdministratorCanManageChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorIsAnonymous, kn) {
					currentKey = ffjtChatMemberAdministratorIsAnonymous
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberAdministratorCanBeEdited, kn) {
					currentKey = ffjtChatMemberAdministratorCanBeEdited
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorUser, kn) {
					currentKey = ffjtChatMemberAdministratorUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberAdministratorStatus, kn) {
					currentKey = ffjtChatMemberAdministratorStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMemberAdministratornosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberAdministratorStatus:
					goto handle_Status

				case ffjtChatMemberAdministratorUser:
					goto handle_User

				case ffjtChatMemberAdministratorCanBeEdited:
					goto handle_CanBeEdited

				case ffjtChatMemberAdministratorIsAnonymous:
					goto handle_IsAnonymous

				case ffjtChatMemberAdministratorCanManageChat:
					goto handle_CanManageChat

				case ffjtChatMemberAdministratorCanDeleteMessages:
					goto handle_CanDeleteMessages

				case ffjtChatMemberAdministratorCanManageVideoChats:
					goto handle_CanManageVideoChats

				case ffjtChatMemberAdministratorCanRestrictMembers:
					goto handle_CanRestrictMembers

				case ffjtChatMemberAdministratorCanPromoteMembers:
					goto handle_CanPromoteMembers

				case ffjtChatMemberAdministratorCanChangeInfo:
					goto handle_CanChangeInfo

				case ffjtChatMemberAdministratorCanInviteUsers:
					goto handle_CanInviteUsers

				case ffjtChatMemberAdministratorCanPostMessages:
					goto handle_CanPostMessages

				case ffjtChatMemberAdministratorCanEditMessages:
					goto handle_CanEditMessages

				case ffjtChatMemberAdministratorCanPinMessages:
					goto handle_CanPinMessages

				case ffjtChatMemberAdministratorCustomTitle:
					goto handle_CustomTitle

				case ffjtChatMemberAdministratornosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanBeEdited:

	/* handler: j.CanBeEdited type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanBeEdited = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanBeEdited = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsAnonymous:

	/* handler: j.IsAnonymous type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsAnonymous = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsAnonymous = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanManageChat:

	/* handler: j.CanManageChat type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanManageChat = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanManageChat = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanDeleteMessages:

	/* handler: j.CanDeleteMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanDeleteMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanDeleteMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanManageVideoChats:

	/* handler: j.CanManageVideoChats type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanManageVideoChats = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanManageVideoChats = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanRestrictMembers:

	/* handler: j.CanRestrictMembers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanRestrictMembers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanRestrictMembers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPromoteMembers:

	/* handler: j.CanPromoteMembers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPromoteMembers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPromoteMembers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanChangeInfo:

	/* handler: j.CanChangeInfo type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanInviteUsers:

	/* handler: j.CanInviteUsers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPostMessages:

	/* handler: j.CanPostMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPostMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPostMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanEditMessages:

	/* handler: j.CanEditMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanEditMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanEditMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPinMessages:

	/* handler: j.CanPinMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPinMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPinMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomTitle:

	/* handler: j.CustomTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CustomTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMemberBanned) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMemberBanned) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	buf.WriteString(`,"until_date":`)
	fflib.FormatBits2(buf, uint64(j.UntilDate), 10, j.UntilDate < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberBannedbase = iota
	ffjtChatMemberBannednosuchkey

	ffjtChatMemberBannedStatus

	ffjtChatMemberBannedUser

	ffjtChatMemberBannedUntilDate
)

var ffjKeyChatMemberBannedStatus = []byte("status")

var ffjKeyChatMemberBannedUser = []byte("user")

var ffjKeyChatMemberBannedUntilDate = []byte("until_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMemberBanned) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMemberBanned) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberBannedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMemberBannednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffjKeyChatMemberBannedStatus, kn) {
						currentKey = ffjtChatMemberBannedStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberBannedUser, kn) {
						currentKey = ffjtChatMemberBannedUser
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberBannedUntilDate, kn) {
						currentKey = ffjtChatMemberBannedUntilDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberBannedUntilDate, kn) {
					currentKey = ffjtChatMemberBannedUntilDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberBannedUser, kn) {
					currentKey = ffjtChatMemberBannedUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberBannedStatus, kn) {
					currentKey = ffjtChatMemberBannedStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMemberBannednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberBannedStatus:
					goto handle_Status

				case ffjtChatMemberBannedUser:
					goto handle_User

				case ffjtChatMemberBannedUntilDate:
					goto handle_UntilDate

				case ffjtChatMemberBannednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UntilDate:

	/* handler: j.UntilDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UntilDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMemberLeft) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMemberLeft) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberLeftbase = iota
	ffjtChatMemberLeftnosuchkey

	ffjtChatMemberLeftStatus

	ffjtChatMemberLeftUser
)

var ffjKeyChatMemberLeftStatus = []byte("status")

var ffjKeyChatMemberLeftUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMemberLeft) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMemberLeft) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberLeftbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMemberLeftnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffjKeyChatMemberLeftStatus, kn) {
						currentKey = ffjtChatMemberLeftStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberLeftUser, kn) {
						currentKey = ffjtChatMemberLeftUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatMemberLeftUser, kn) {
					currentKey = ffjtChatMemberLeftUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberLeftStatus, kn) {
					currentKey = ffjtChatMemberLeftStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMemberLeftnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberLeftStatus:
					goto handle_Status

				case ffjtChatMemberLeftUser:
					goto handle_User

				case ffjtChatMemberLeftnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMemberMember) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMemberMember) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberMemberbase = iota
	ffjtChatMemberMembernosuchkey

	ffjtChatMemberMemberStatus

	ffjtChatMemberMemberUser
)

var ffjKeyChatMemberMemberStatus = []byte("status")

var ffjKeyChatMemberMemberUser = []byte("user")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMemberMember) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMemberMember) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberMemberbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMemberMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffjKeyChatMemberMemberStatus, kn) {
						currentKey = ffjtChatMemberMemberStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberMemberUser, kn) {
						currentKey = ffjtChatMemberMemberUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatMemberMemberUser, kn) {
					currentKey = ffjtChatMemberMemberUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberMemberStatus, kn) {
					currentKey = ffjtChatMemberMemberStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMemberMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberMemberStatus:
					goto handle_Status

				case ffjtChatMemberMemberUser:
					goto handle_User

				case ffjtChatMemberMembernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMemberOwner) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMemberOwner) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	if j.IsAnonymous {
		buf.WriteString(`,"is_anonymous":true`)
	} else {
		buf.WriteString(`,"is_anonymous":false`)
	}
	buf.WriteByte(',')
	if len(j.CustomTitle) != 0 {
		buf.WriteString(`"custom_title":`)
		fflib.WriteJsonString(buf, string(j.CustomTitle))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberOwnerbase = iota
	ffjtChatMemberOwnernosuchkey

	ffjtChatMemberOwnerStatus

	ffjtChatMemberOwnerUser

	ffjtChatMemberOwnerIsAnonymous

	ffjtChatMemberOwnerCustomTitle
)

var ffjKeyChatMemberOwnerStatus = []byte("status")

var ffjKeyChatMemberOwnerUser = []byte("user")

var ffjKeyChatMemberOwnerIsAnonymous = []byte("is_anonymous")

var ffjKeyChatMemberOwnerCustomTitle = []byte("custom_title")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMemberOwner) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMemberOwner) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberOwnerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMemberOwnernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChatMemberOwnerCustomTitle, kn) {
						currentKey = ffjtChatMemberOwnerCustomTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatMemberOwnerIsAnonymous, kn) {
						currentKey = ffjtChatMemberOwnerIsAnonymous
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatMemberOwnerStatus, kn) {
						currentKey = ffjtChatMemberOwnerStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberOwnerUser, kn) {
						currentKey = ffjtChatMemberOwnerUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatMemberOwnerCustomTitle, kn) {
					currentKey = ffjtChatMemberOwnerCustomTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberOwnerIsAnonymous, kn) {
					currentKey = ffjtChatMemberOwnerIsAnonymous
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberOwnerUser, kn) {
					currentKey = ffjtChatMemberOwnerUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberOwnerStatus, kn) {
					currentKey = ffjtChatMemberOwnerStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMemberOwnernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberOwnerStatus:
					goto handle_Status

				case ffjtChatMemberOwnerUser:
					goto handle_User

				case ffjtChatMemberOwnerIsAnonymous:
					goto handle_IsAnonymous

				case ffjtChatMemberOwnerCustomTitle:
					goto handle_CustomTitle

				case ffjtChatMemberOwnernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsAnonymous:

	/* handler: j.IsAnonymous type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsAnonymous = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsAnonymous = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomTitle:

	/* handler: j.CustomTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CustomTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMemberRestricted) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMemberRestricted) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"status":`)
	fflib.WriteJsonString(buf, string(j.Status))
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	if j.IsMember {
		buf.WriteString(`,"is_member":true`)
	} else {
		buf.WriteString(`,"is_member":false`)
	}
	if j.CanChangeInfo {
		buf.WriteString(`,"can_change_info":true`)
	} else {
		buf.WriteString(`,"can_change_info":false`)
	}
	if j.CanInviteUsers {
		buf.WriteString(`,"can_invite_users":true`)
	} else {
		buf.WriteString(`,"can_invite_users":false`)
	}
	if j.CanPinMessages {
		buf.WriteString(`,"can_pin_messages":true`)
	} else {
		buf.WriteString(`,"can_pin_messages":false`)
	}
	if j.CanSendMessages {
		buf.WriteString(`,"can_send_messages":true`)
	} else {
		buf.WriteString(`,"can_send_messages":false`)
	}
	if j.CanSendMediaMessages {
		buf.WriteString(`,"can_send_media_messages":true`)
	} else {
		buf.WriteString(`,"can_send_media_messages":false`)
	}
	if j.CanSendPolls {
		buf.WriteString(`,"can_send_polls":true`)
	} else {
		buf.WriteString(`,"can_send_polls":false`)
	}
	if j.CanSendOtherMessages {
		buf.WriteString(`,"can_send_other_messages":true`)
	} else {
		buf.WriteString(`,"can_send_other_messages":false`)
	}
	if j.CanAddWebPagePreviews {
		buf.WriteString(`,"can_add_web_page_previews":true`)
	} else {
		buf.WriteString(`,"can_add_web_page_previews":false`)
	}
	buf.WriteString(`,"until_date":`)
	fflib.FormatBits2(buf, uint64(j.UntilDate), 10, j.UntilDate < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberRestrictedbase = iota
	ffjtChatMemberRestrictednosuchkey

	ffjtChatMemberRestrictedStatus

	ffjtChatMemberRestrictedUser

	ffjtChatMemberRestrictedIsMember

	ffjtChatMemberRestrictedCanChangeInfo

	ffjtChatMemberRestrictedCanInviteUsers

	ffjtChatMemberRestrictedCanPinMessages

	ffjtChatMemberRestrictedCanSendMessages

	ffjtChatMemberRestrictedCanSendMediaMessages

	ffjtChatMemberRestrictedCanSendPolls

	ffjtChatMemberRestrictedCanSendOtherMessages

	ffjtChatMemberRestrictedCanAddWebPagePreviews

	ffjtChatMemberRestrictedUntilDate
)

var ffjKeyChatMemberRestrictedStatus = []byte("status")

var ffjKeyChatMemberRestrictedUser = []byte("user")

var ffjKeyChatMemberRestrictedIsMember = []byte("is_member")

var ffjKeyChatMemberRestrictedCanChangeInfo = []byte("can_change_info")

var ffjKeyChatMemberRestrictedCanInviteUsers = []byte("can_invite_users")

var ffjKeyChatMemberRestrictedCanPinMessages = []byte("can_pin_messages")

var ffjKeyChatMemberRestrictedCanSendMessages = []byte("can_send_messages")

var ffjKeyChatMemberRestrictedCanSendMediaMessages = []byte("can_send_media_messages")

var ffjKeyChatMemberRestrictedCanSendPolls = []byte("can_send_polls")

var ffjKeyChatMemberRestrictedCanSendOtherMessages = []byte("can_send_other_messages")

var ffjKeyChatMemberRestrictedCanAddWebPagePreviews = []byte("can_add_web_page_previews")

var ffjKeyChatMemberRestrictedUntilDate = []byte("until_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMemberRestricted) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMemberRestricted) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberRestrictedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMemberRestrictednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChatMemberRestrictedCanChangeInfo, kn) {
						currentKey = ffjtChatMemberRestrictedCanChangeInfo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedCanInviteUsers, kn) {
						currentKey = ffjtChatMemberRestrictedCanInviteUsers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedCanPinMessages, kn) {
						currentKey = ffjtChatMemberRestrictedCanPinMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedCanSendMessages, kn) {
						currentKey = ffjtChatMemberRestrictedCanSendMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedCanSendMediaMessages, kn) {
						currentKey = ffjtChatMemberRestrictedCanSendMediaMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedCanSendPolls, kn) {
						currentKey = ffjtChatMemberRestrictedCanSendPolls
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedCanSendOtherMessages, kn) {
						currentKey = ffjtChatMemberRestrictedCanSendOtherMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedCanAddWebPagePreviews, kn) {
						currentKey = ffjtChatMemberRestrictedCanAddWebPagePreviews
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatMemberRestrictedIsMember, kn) {
						currentKey = ffjtChatMemberRestrictedIsMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatMemberRestrictedStatus, kn) {
						currentKey = ffjtChatMemberRestrictedStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberRestrictedUser, kn) {
						currentKey = ffjtChatMemberRestrictedUser
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberRestrictedUntilDate, kn) {
						currentKey = ffjtChatMemberRestrictedUntilDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberRestrictedUntilDate, kn) {
					currentKey = ffjtChatMemberRestrictedUntilDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedCanAddWebPagePreviews, kn) {
					currentKey = ffjtChatMemberRestrictedCanAddWebPagePreviews
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedCanSendOtherMessages, kn) {
					currentKey = ffjtChatMemberRestrictedCanSendOtherMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedCanSendPolls, kn) {
					currentKey = ffjtChatMemberRestrictedCanSendPolls
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedCanSendMediaMessages, kn) {
					currentKey = ffjtChatMemberRestrictedCanSendMediaMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedCanSendMessages, kn) {
					currentKey = ffjtChatMemberRestrictedCanSendMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedCanPinMessages, kn) {
					currentKey = ffjtChatMemberRestrictedCanPinMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedCanInviteUsers, kn) {
					currentKey = ffjtChatMemberRestrictedCanInviteUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberRestrictedCanChangeInfo, kn) {
					currentKey = ffjtChatMemberRestrictedCanChangeInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedIsMember, kn) {
					currentKey = ffjtChatMemberRestrictedIsMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedUser, kn) {
					currentKey = ffjtChatMemberRestrictedUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberRestrictedStatus, kn) {
					currentKey = ffjtChatMemberRestrictedStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMemberRestrictednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberRestrictedStatus:
					goto handle_Status

				case ffjtChatMemberRestrictedUser:
					goto handle_User

				case ffjtChatMemberRestrictedIsMember:
					goto handle_IsMember

				case ffjtChatMemberRestrictedCanChangeInfo:
					goto handle_CanChangeInfo

				case ffjtChatMemberRestrictedCanInviteUsers:
					goto handle_CanInviteUsers

				case ffjtChatMemberRestrictedCanPinMessages:
					goto handle_CanPinMessages

				case ffjtChatMemberRestrictedCanSendMessages:
					goto handle_CanSendMessages

				case ffjtChatMemberRestrictedCanSendMediaMessages:
					goto handle_CanSendMediaMessages

				case ffjtChatMemberRestrictedCanSendPolls:
					goto handle_CanSendPolls

				case ffjtChatMemberRestrictedCanSendOtherMessages:
					goto handle_CanSendOtherMessages

				case ffjtChatMemberRestrictedCanAddWebPagePreviews:
					goto handle_CanAddWebPagePreviews

				case ffjtChatMemberRestrictedUntilDate:
					goto handle_UntilDate

				case ffjtChatMemberRestrictednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Status:

	/* handler: j.Status type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Status = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsMember:

	/* handler: j.IsMember type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsMember = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsMember = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanChangeInfo:

	/* handler: j.CanChangeInfo type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanInviteUsers:

	/* handler: j.CanInviteUsers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPinMessages:

	/* handler: j.CanPinMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPinMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPinMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendMessages:

	/* handler: j.CanSendMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendMediaMessages:

	/* handler: j.CanSendMediaMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendMediaMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendMediaMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendPolls:

	/* handler: j.CanSendPolls type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendPolls = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendPolls = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendOtherMessages:

	/* handler: j.CanSendOtherMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendOtherMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendOtherMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanAddWebPagePreviews:

	/* handler: j.CanAddWebPagePreviews type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanAddWebPagePreviews = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanAddWebPagePreviews = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UntilDate:

	/* handler: j.UntilDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UntilDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMemberUpdated) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMemberUpdated) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Chat != nil {
		buf.WriteString(`{ "chat":`)

		{

			err = j.Chat.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{ "chat":null`)
	}
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteString(`,"date":`)
	fflib.FormatBits2(buf, uint64(j.Date), 10, j.Date < 0)
	if j.OldChatMember != nil {
		buf.WriteString(`,"old_chat_member":`)
		/* Interface types must use runtime reflection. type=model.ChatMember kind=interface */
		err = buf.Encode(j.OldChatMember)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`,"old_chat_member":null`)
	}
	if j.NewChatMember != nil {
		buf.WriteString(`,"new_chat_member":`)
		/* Interface types must use runtime reflection. type=model.ChatMember kind=interface */
		err = buf.Encode(j.NewChatMember)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`,"new_chat_member":null`)
	}
	buf.WriteByte(',')
	if j.InviteLink != nil {
		if true {
			buf.WriteString(`"invite_link":`)

			{

				err = j.InviteLink.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberUpdatedbase = iota
	ffjtChatMemberUpdatednosuchkey

	ffjtChatMemberUpdatedChat

	ffjtChatMemberUpdatedFrom

	ffjtChatMemberUpdatedDate

	ffjtChatMemberUpdatedOldChatMember

	ffjtChatMemberUpdatedNewChatMember

	ffjtChatMemberUpdatedInviteLink
)

var ffjKeyChatMemberUpdatedChat = []byte("chat")

var ffjKeyChatMemberUpdatedFrom = []byte("from")

var ffjKeyChatMemberUpdatedDate = []byte("date")

var ffjKeyChatMemberUpdatedOldChatMember = []byte("old_chat_member")

var ffjKeyChatMemberUpdatedNewChatMember = []byte("new_chat_member")

var ffjKeyChatMemberUpdatedInviteLink = []byte("invite_link")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMemberUpdated) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMemberUpdated) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberUpdatedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMemberUpdatednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChatMemberUpdatedChat, kn) {
						currentKey = ffjtChatMemberUpdatedChat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyChatMemberUpdatedDate, kn) {
						currentKey = ffjtChatMemberUpdatedDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyChatMemberUpdatedFrom, kn) {
						currentKey = ffjtChatMemberUpdatedFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatMemberUpdatedInviteLink, kn) {
						currentKey = ffjtChatMemberUpdatedInviteLink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyChatMemberUpdatedNewChatMember, kn) {
						currentKey = ffjtChatMemberUpdatedNewChatMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyChatMemberUpdatedOldChatMember, kn) {
						currentKey = ffjtChatMemberUpdatedOldChatMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatMemberUpdatedInviteLink, kn) {
					currentKey = ffjtChatMemberUpdatedInviteLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberUpdatedNewChatMember, kn) {
					currentKey = ffjtChatMemberUpdatedNewChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberUpdatedOldChatMember, kn) {
					currentKey = ffjtChatMemberUpdatedOldChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatMemberUpdatedDate, kn) {
					currentKey = ffjtChatMemberUpdatedDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatMemberUpdatedFrom, kn) {
					currentKey = ffjtChatMemberUpdatedFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatMemberUpdatedChat, kn) {
					currentKey = ffjtChatMemberUpdatedChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMemberUpdatednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberUpdatedChat:
					goto handle_Chat

				case ffjtChatMemberUpdatedFrom:
					goto handle_From

				case ffjtChatMemberUpdatedDate:
					goto handle_Date

				case ffjtChatMemberUpdatedOldChatMember:
					goto handle_OldChatMember

				case ffjtChatMemberUpdatedNewChatMember:
					goto handle_NewChatMember

				case ffjtChatMemberUpdatedInviteLink:
					goto handle_InviteLink

				case ffjtChatMemberUpdatednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Chat:

	/* handler: j.Chat type=model.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Chat = nil

		} else {

			if j.Chat == nil {
				j.Chat = new(Chat)
			}

			err = j.Chat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: j.Date type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Date = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OldChatMember:

	/* handler: j.OldChatMember type=model.ChatMember kind=interface quoted=false*/

	{
		/* Falling back. type=model.ChatMember kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.OldChatMember)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMember:

	/* handler: j.NewChatMember type=model.ChatMember kind=interface quoted=false*/

	{
		/* Falling back. type=model.ChatMember kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.NewChatMember)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InviteLink:

	/* handler: j.InviteLink type=model.ChatInviteLink kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.InviteLink = nil

		} else {

			if j.InviteLink == nil {
				j.InviteLink = new(ChatInviteLink)
			}

			err = j.InviteLink.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatPermissions) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatPermissions) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.CanSendMessages != false {
		if j.CanSendMessages {
			buf.WriteString(`"can_send_messages":true`)
		} else {
			buf.WriteString(`"can_send_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanSendMediaMessages != false {
		if j.CanSendMediaMessages {
			buf.WriteString(`"can_send_media_messages":true`)
		} else {
			buf.WriteString(`"can_send_media_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanSendPolls != false {
		if j.CanSendPolls {
			buf.WriteString(`"can_send_polls":true`)
		} else {
			buf.WriteString(`"can_send_polls":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanSendOtherMessages != false {
		if j.CanSendOtherMessages {
			buf.WriteString(`"can_send_other_messages":true`)
		} else {
			buf.WriteString(`"can_send_other_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanAddWebPagePreviews != false {
		if j.CanAddWebPagePreviews {
			buf.WriteString(`"can_add_web_page_previews":true`)
		} else {
			buf.WriteString(`"can_add_web_page_previews":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanChangeInfo != false {
		if j.CanChangeInfo {
			buf.WriteString(`"can_change_info":true`)
		} else {
			buf.WriteString(`"can_change_info":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanInviteUsers != false {
		if j.CanInviteUsers {
			buf.WriteString(`"can_invite_users":true`)
		} else {
			buf.WriteString(`"can_invite_users":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanPinMessages != false {
		if j.CanPinMessages {
			buf.WriteString(`"can_pin_messages":true`)
		} else {
			buf.WriteString(`"can_pin_messages":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatPermissionsbase = iota
	ffjtChatPermissionsnosuchkey

	ffjtChatPermissionsCanSendMessages

	ffjtChatPermissionsCanSendMediaMessages

	ffjtChatPermissionsCanSendPolls

	ffjtChatPermissionsCanSendOtherMessages

	ffjtChatPermissionsCanAddWebPagePreviews

	ffjtChatPermissionsCanChangeInfo

	ffjtChatPermissionsCanInviteUsers

	ffjtChatPermissionsCanPinMessages
)

var ffjKeyChatPermissionsCanSendMessages = []byte("can_send_messages")

var ffjKeyChatPermissionsCanSendMediaMessages = []byte("can_send_media_messages")

var ffjKeyChatPermissionsCanSendPolls = []byte("can_send_polls")

var ffjKeyChatPermissionsCanSendOtherMessages = []byte("can_send_other_messages")

var ffjKeyChatPermissionsCanAddWebPagePreviews = []byte("can_add_web_page_previews")

var ffjKeyChatPermissionsCanChangeInfo = []byte("can_change_info")

var ffjKeyChatPermissionsCanInviteUsers = []byte("can_invite_users")

var ffjKeyChatPermissionsCanPinMessages = []byte("can_pin_messages")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatPermissions) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatPermissions) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatPermissionsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatPermissionsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyChatPermissionsCanSendMessages, kn) {
						currentKey = ffjtChatPermissionsCanSendMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissionsCanSendMediaMessages, kn) {
						currentKey = ffjtChatPermissionsCanSendMediaMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissionsCanSendPolls, kn) {
						currentKey = ffjtChatPermissionsCanSendPolls
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissionsCanSendOtherMessages, kn) {
						currentKey = ffjtChatPermissionsCanSendOtherMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissionsCanAddWebPagePreviews, kn) {
						currentKey = ffjtChatPermissionsCanAddWebPagePreviews
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissionsCanChangeInfo, kn) {
						currentKey = ffjtChatPermissionsCanChangeInfo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissionsCanInviteUsers, kn) {
						currentKey = ffjtChatPermissionsCanInviteUsers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPermissionsCanPinMessages, kn) {
						currentKey = ffjtChatPermissionsCanPinMessages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatPermissionsCanPinMessages, kn) {
					currentKey = ffjtChatPermissionsCanPinMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPermissionsCanInviteUsers, kn) {
					currentKey = ffjtChatPermissionsCanInviteUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatPermissionsCanChangeInfo, kn) {
					currentKey = ffjtChatPermissionsCanChangeInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPermissionsCanAddWebPagePreviews, kn) {
					currentKey = ffjtChatPermissionsCanAddWebPagePreviews
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPermissionsCanSendOtherMessages, kn) {
					currentKey = ffjtChatPermissionsCanSendOtherMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPermissionsCanSendPolls, kn) {
					currentKey = ffjtChatPermissionsCanSendPolls
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPermissionsCanSendMediaMessages, kn) {
					currentKey = ffjtChatPermissionsCanSendMediaMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPermissionsCanSendMessages, kn) {
					currentKey = ffjtChatPermissionsCanSendMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatPermissionsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatPermissionsCanSendMessages:
					goto handle_CanSendMessages

				case ffjtChatPermissionsCanSendMediaMessages:
					goto handle_CanSendMediaMessages

				case ffjtChatPermissionsCanSendPolls:
					goto handle_CanSendPolls

				case ffjtChatPermissionsCanSendOtherMessages:
					goto handle_CanSendOtherMessages

				case ffjtChatPermissionsCanAddWebPagePreviews:
					goto handle_CanAddWebPagePreviews

				case ffjtChatPermissionsCanChangeInfo:
					goto handle_CanChangeInfo

				case ffjtChatPermissionsCanInviteUsers:
					goto handle_CanInviteUsers

				case ffjtChatPermissionsCanPinMessages:
					goto handle_CanPinMessages

				case ffjtChatPermissionsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CanSendMessages:

	/* handler: j.CanSendMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendMediaMessages:

	/* handler: j.CanSendMediaMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendMediaMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendMediaMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendPolls:

	/* handler: j.CanSendPolls type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendPolls = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendPolls = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanSendOtherMessages:

	/* handler: j.CanSendOtherMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanSendOtherMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanSendOtherMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanAddWebPagePreviews:

	/* handler: j.CanAddWebPagePreviews type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanAddWebPagePreviews = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanAddWebPagePreviews = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanChangeInfo:

	/* handler: j.CanChangeInfo type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanChangeInfo = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanInviteUsers:

	/* handler: j.CanInviteUsers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanInviteUsers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanPinMessages:

	/* handler: j.CanPinMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanPinMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanPinMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatPhoto) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatPhoto) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"small_file_id":`)
	fflib.WriteJsonString(buf, string(j.SmallFileID))
	buf.WriteString(`,"small_file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.SmallFileUniqueID))
	buf.WriteString(`,"big_file_id":`)
	fflib.WriteJsonString(buf, string(j.BigFileID))
	buf.WriteString(`,"big_file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.BigFileUniqueID))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatPhotobase = iota
	ffjtChatPhotonosuchkey

	ffjtChatPhotoSmallFileID

	ffjtChatPhotoSmallFileUniqueID

	ffjtChatPhotoBigFileID

	ffjtChatPhotoBigFileUniqueID
)

var ffjKeyChatPhotoSmallFileID = []byte("small_file_id")

var ffjKeyChatPhotoSmallFileUniqueID = []byte("small_file_unique_id")

var ffjKeyChatPhotoBigFileID = []byte("big_file_id")

var ffjKeyChatPhotoBigFileUniqueID = []byte("big_file_unique_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatPhoto) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatPhoto) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatPhotobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyChatPhotoBigFileID, kn) {
						currentKey = ffjtChatPhotoBigFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPhotoBigFileUniqueID, kn) {
						currentKey = ffjtChatPhotoBigFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyChatPhotoSmallFileID, kn) {
						currentKey = ffjtChatPhotoSmallFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatPhotoSmallFileUniqueID, kn) {
						currentKey = ffjtChatPhotoSmallFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyChatPhotoBigFileUniqueID, kn) {
					currentKey = ffjtChatPhotoBigFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChatPhotoBigFileID, kn) {
					currentKey = ffjtChatPhotoBigFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPhotoSmallFileUniqueID, kn) {
					currentKey = ffjtChatPhotoSmallFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatPhotoSmallFileID, kn) {
					currentKey = ffjtChatPhotoSmallFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatPhotoSmallFileID:
					goto handle_SmallFileID

				case ffjtChatPhotoSmallFileUniqueID:
					goto handle_SmallFileUniqueID

				case ffjtChatPhotoBigFileID:
					goto handle_BigFileID

				case ffjtChatPhotoBigFileUniqueID:
					goto handle_BigFileUniqueID

				case ffjtChatPhotonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_SmallFileID:

	/* handler: j.SmallFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SmallFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SmallFileUniqueID:

	/* handler: j.SmallFileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SmallFileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BigFileID:

	/* handler: j.BigFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BigFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BigFileUniqueID:

	/* handler: j.BigFileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BigFileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChosenInlineResult) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChosenInlineResult) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"result_id":`)
	fflib.WriteJsonString(buf, string(j.ResultID))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteByte(',')
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.InlineMessageID) != 0 {
		buf.WriteString(`"inline_message_id":`)
		fflib.WriteJsonString(buf, string(j.InlineMessageID))
		buf.WriteByte(',')
	}
	buf.WriteString(`"query":`)
	fflib.WriteJsonString(buf, string(j.Query))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChosenInlineResultbase = iota
	ffjtChosenInlineResultnosuchkey

	ffjtChosenInlineResultResultID

	ffjtChosenInlineResultFrom

	ffjtChosenInlineResultLocation

	ffjtChosenInlineResultInlineMessageID

	ffjtChosenInlineResultQuery
)

var ffjKeyChosenInlineResultResultID = []byte("result_id")

var ffjKeyChosenInlineResultFrom = []byte("from")

var ffjKeyChosenInlineResultLocation = []byte("location")

var ffjKeyChosenInlineResultInlineMessageID = []byte("inline_message_id")

var ffjKeyChosenInlineResultQuery = []byte("query")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChosenInlineResult) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChosenInlineResult) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChosenInlineResultbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChosenInlineResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyChosenInlineResultFrom, kn) {
						currentKey = ffjtChosenInlineResultFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChosenInlineResultInlineMessageID, kn) {
						currentKey = ffjtChosenInlineResultInlineMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChosenInlineResultLocation, kn) {
						currentKey = ffjtChosenInlineResultLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyChosenInlineResultQuery, kn) {
						currentKey = ffjtChosenInlineResultQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyChosenInlineResultResultID, kn) {
						currentKey = ffjtChosenInlineResultResultID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultQuery, kn) {
					currentKey = ffjtChosenInlineResultQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChosenInlineResultInlineMessageID, kn) {
					currentKey = ffjtChosenInlineResultInlineMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultLocation, kn) {
					currentKey = ffjtChosenInlineResultLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultFrom, kn) {
					currentKey = ffjtChosenInlineResultFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChosenInlineResultResultID, kn) {
					currentKey = ffjtChosenInlineResultResultID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChosenInlineResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChosenInlineResultResultID:
					goto handle_ResultID

				case ffjtChosenInlineResultFrom:
					goto handle_From

				case ffjtChosenInlineResultLocation:
					goto handle_Location

				case ffjtChosenInlineResultInlineMessageID:
					goto handle_InlineMessageID

				case ffjtChosenInlineResultQuery:
					goto handle_Query

				case ffjtChosenInlineResultnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ResultID:

	/* handler: j.ResultID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ResultID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=model.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineMessageID:

	/* handler: j.InlineMessageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InlineMessageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: j.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Contact) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Contact) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if j.UserID != 0 {
		buf.WriteString(`"user_id":`)
		fflib.FormatBits2(buf, uint64(j.UserID), 10, j.UserID < 0)
		buf.WriteByte(',')
	}
	if len(j.Vcard) != 0 {
		buf.WriteString(`"vcard":`)
		fflib.WriteJsonString(buf, string(j.Vcard))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtContactbase = iota
	ffjtContactnosuchkey

	ffjtContactPhoneNumber

	ffjtContactFirstName

	ffjtContactLastName

	ffjtContactUserID

	ffjtContactVcard
)

var ffjKeyContactPhoneNumber = []byte("phone_number")

var ffjKeyContactFirstName = []byte("first_name")

var ffjKeyContactLastName = []byte("last_name")

var ffjKeyContactUserID = []byte("user_id")

var ffjKeyContactVcard = []byte("vcard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Contact) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Contact) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtContactbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyContactFirstName, kn) {
						currentKey = ffjtContactFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyContactLastName, kn) {
						currentKey = ffjtContactLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyContactPhoneNumber, kn) {
						currentKey = ffjtContactPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyContactUserID, kn) {
						currentKey = ffjtContactUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyContactVcard, kn) {
						currentKey = ffjtContactVcard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyContactVcard, kn) {
					currentKey = ffjtContactVcard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactUserID, kn) {
					currentKey = ffjtContactUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactLastName, kn) {
					currentKey = ffjtContactLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactFirstName, kn) {
					currentKey = ffjtContactFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyContactPhoneNumber, kn) {
					currentKey = ffjtContactPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtContactPhoneNumber:
					goto handle_PhoneNumber

				case ffjtContactFirstName:
					goto handle_FirstName

				case ffjtContactLastName:
					goto handle_LastName

				case ffjtContactUserID:
					goto handle_UserID

				case ffjtContactVcard:
					goto handle_Vcard

				case ffjtContactnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UserID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Vcard:

	/* handler: j.Vcard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Vcard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Dice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Dice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"emoji":`)
	fflib.WriteJsonString(buf, string(j.Emoji))
	buf.WriteString(`,"value":`)
	fflib.FormatBits2(buf, uint64(j.Value), 10, j.Value < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDicebase = iota
	ffjtDicenosuchkey

	ffjtDiceEmoji

	ffjtDiceValue
)

var ffjKeyDiceEmoji = []byte("emoji")

var ffjKeyDiceValue = []byte("value")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Dice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Dice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyDiceEmoji, kn) {
						currentKey = ffjtDiceEmoji
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyDiceValue, kn) {
						currentKey = ffjtDiceValue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyDiceValue, kn) {
					currentKey = ffjtDiceValue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDiceEmoji, kn) {
					currentKey = ffjtDiceEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDiceEmoji:
					goto handle_Emoji

				case ffjtDiceValue:
					goto handle_Value

				case ffjtDicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Emoji:

	/* handler: j.Emoji type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Emoji = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: j.Value type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Value = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Document) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Document) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteByte(',')
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(j.FileName))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDocumentbase = iota
	ffjtDocumentnosuchkey

	ffjtDocumentFileID

	ffjtDocumentFileUniqueID

	ffjtDocumentThumb

	ffjtDocumentFileName

	ffjtDocumentMimeType

	ffjtDocumentFileSize
)

var ffjKeyDocumentFileID = []byte("file_id")

var ffjKeyDocumentFileUniqueID = []byte("file_unique_id")

var ffjKeyDocumentThumb = []byte("thumb")

var ffjKeyDocumentFileName = []byte("file_name")

var ffjKeyDocumentMimeType = []byte("mime_type")

var ffjKeyDocumentFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Document) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Document) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyDocumentFileID, kn) {
						currentKey = ffjtDocumentFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDocumentFileUniqueID, kn) {
						currentKey = ffjtDocumentFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDocumentFileName, kn) {
						currentKey = ffjtDocumentFileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDocumentFileSize, kn) {
						currentKey = ffjtDocumentFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyDocumentMimeType, kn) {
						currentKey = ffjtDocumentMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyDocumentThumb, kn) {
						currentKey = ffjtDocumentThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyDocumentFileSize, kn) {
					currentKey = ffjtDocumentFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentMimeType, kn) {
					currentKey = ffjtDocumentMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentFileName, kn) {
					currentKey = ffjtDocumentFileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDocumentThumb, kn) {
					currentKey = ffjtDocumentThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentFileUniqueID, kn) {
					currentKey = ffjtDocumentFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentFileID, kn) {
					currentKey = ffjtDocumentFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDocumentFileID:
					goto handle_FileID

				case ffjtDocumentFileUniqueID:
					goto handle_FileUniqueID

				case ffjtDocumentThumb:
					goto handle_Thumb

				case ffjtDocumentFileName:
					goto handle_FileName

				case ffjtDocumentMimeType:
					goto handle_MimeType

				case ffjtDocumentFileSize:
					goto handle_FileSize

				case ffjtDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=model.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: j.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EncryptedCredentials) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EncryptedCredentials) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"data":`)
	fflib.WriteJsonString(buf, string(j.Data))
	buf.WriteString(`,"hash":`)
	fflib.WriteJsonString(buf, string(j.Hash))
	buf.WriteString(`,"secret":`)
	fflib.WriteJsonString(buf, string(j.Secret))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEncryptedCredentialsbase = iota
	ffjtEncryptedCredentialsnosuchkey

	ffjtEncryptedCredentialsData

	ffjtEncryptedCredentialsHash

	ffjtEncryptedCredentialsSecret
)

var ffjKeyEncryptedCredentialsData = []byte("data")

var ffjKeyEncryptedCredentialsHash = []byte("hash")

var ffjKeyEncryptedCredentialsSecret = []byte("secret")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EncryptedCredentials) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EncryptedCredentials) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEncryptedCredentialsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEncryptedCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyEncryptedCredentialsData, kn) {
						currentKey = ffjtEncryptedCredentialsData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyEncryptedCredentialsHash, kn) {
						currentKey = ffjtEncryptedCredentialsHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEncryptedCredentialsSecret, kn) {
						currentKey = ffjtEncryptedCredentialsSecret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyEncryptedCredentialsSecret, kn) {
					currentKey = ffjtEncryptedCredentialsSecret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedCredentialsHash, kn) {
					currentKey = ffjtEncryptedCredentialsHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedCredentialsData, kn) {
					currentKey = ffjtEncryptedCredentialsData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEncryptedCredentialsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEncryptedCredentialsData:
					goto handle_Data

				case ffjtEncryptedCredentialsHash:
					goto handle_Hash

				case ffjtEncryptedCredentialsSecret:
					goto handle_Secret

				case ffjtEncryptedCredentialsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Data:

	/* handler: j.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hash:

	/* handler: j.Hash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Hash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: j.Secret type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Secret = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *EncryptedPassportElement) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *EncryptedPassportElement) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteByte(',')
	if len(j.Data) != 0 {
		buf.WriteString(`"data":`)
		fflib.WriteJsonString(buf, string(j.Data))
		buf.WriteByte(',')
	}
	if len(j.PhoneNumber) != 0 {
		buf.WriteString(`"phone_number":`)
		fflib.WriteJsonString(buf, string(j.PhoneNumber))
		buf.WriteByte(',')
	}
	if len(j.Email) != 0 {
		buf.WriteString(`"email":`)
		fflib.WriteJsonString(buf, string(j.Email))
		buf.WriteByte(',')
	}
	if len(j.Files) != 0 {
		buf.WriteString(`"files":`)
		if j.Files != nil {
			buf.WriteString(`[`)
			for i, v := range j.Files {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.FrontSide != nil {
		if true {
			buf.WriteString(`"front_side":`)

			{

				err = j.FrontSide.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ReverseSide != nil {
		if true {
			buf.WriteString(`"reverse_side":`)

			{

				err = j.ReverseSide.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Selfie != nil {
		if true {
			buf.WriteString(`"selfie":`)

			{

				err = j.Selfie.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"translation":`)
	if j.Translation != nil {
		buf.WriteString(`[`)
		for i, v := range j.Translation {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				if v == nil {
					buf.WriteString("null")
				} else {

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"hash":`)
	fflib.WriteJsonString(buf, string(j.Hash))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEncryptedPassportElementbase = iota
	ffjtEncryptedPassportElementnosuchkey

	ffjtEncryptedPassportElementType

	ffjtEncryptedPassportElementData

	ffjtEncryptedPassportElementPhoneNumber

	ffjtEncryptedPassportElementEmail

	ffjtEncryptedPassportElementFiles

	ffjtEncryptedPassportElementFrontSide

	ffjtEncryptedPassportElementReverseSide

	ffjtEncryptedPassportElementSelfie

	ffjtEncryptedPassportElementTranslation

	ffjtEncryptedPassportElementHash
)

var ffjKeyEncryptedPassportElementType = []byte("type")

var ffjKeyEncryptedPassportElementData = []byte("data")

var ffjKeyEncryptedPassportElementPhoneNumber = []byte("phone_number")

var ffjKeyEncryptedPassportElementEmail = []byte("email")

var ffjKeyEncryptedPassportElementFiles = []byte("files")

var ffjKeyEncryptedPassportElementFrontSide = []byte("front_side")

var ffjKeyEncryptedPassportElementReverseSide = []byte("reverse_side")

var ffjKeyEncryptedPassportElementSelfie = []byte("selfie")

var ffjKeyEncryptedPassportElementTranslation = []byte("translation")

var ffjKeyEncryptedPassportElementHash = []byte("hash")

// UnmarshalJSON umarshall json - template of ffjson
func (j *EncryptedPassportElement) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *EncryptedPassportElement) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEncryptedPassportElementbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEncryptedPassportElementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyEncryptedPassportElementData, kn) {
						currentKey = ffjtEncryptedPassportElementData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyEncryptedPassportElementEmail, kn) {
						currentKey = ffjtEncryptedPassportElementEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyEncryptedPassportElementFiles, kn) {
						currentKey = ffjtEncryptedPassportElementFiles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEncryptedPassportElementFrontSide, kn) {
						currentKey = ffjtEncryptedPassportElementFrontSide
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyEncryptedPassportElementHash, kn) {
						currentKey = ffjtEncryptedPassportElementHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyEncryptedPassportElementPhoneNumber, kn) {
						currentKey = ffjtEncryptedPassportElementPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyEncryptedPassportElementReverseSide, kn) {
						currentKey = ffjtEncryptedPassportElementReverseSide
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEncryptedPassportElementSelfie, kn) {
						currentKey = ffjtEncryptedPassportElementSelfie
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyEncryptedPassportElementType, kn) {
						currentKey = ffjtEncryptedPassportElementType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEncryptedPassportElementTranslation, kn) {
						currentKey = ffjtEncryptedPassportElementTranslation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementHash, kn) {
					currentKey = ffjtEncryptedPassportElementHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementTranslation, kn) {
					currentKey = ffjtEncryptedPassportElementTranslation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementSelfie, kn) {
					currentKey = ffjtEncryptedPassportElementSelfie
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementReverseSide, kn) {
					currentKey = ffjtEncryptedPassportElementReverseSide
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementFrontSide, kn) {
					currentKey = ffjtEncryptedPassportElementFrontSide
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEncryptedPassportElementFiles, kn) {
					currentKey = ffjtEncryptedPassportElementFiles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedPassportElementEmail, kn) {
					currentKey = ffjtEncryptedPassportElementEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyEncryptedPassportElementPhoneNumber, kn) {
					currentKey = ffjtEncryptedPassportElementPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedPassportElementData, kn) {
					currentKey = ffjtEncryptedPassportElementData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEncryptedPassportElementType, kn) {
					currentKey = ffjtEncryptedPassportElementType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEncryptedPassportElementnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEncryptedPassportElementType:
					goto handle_Type

				case ffjtEncryptedPassportElementData:
					goto handle_Data

				case ffjtEncryptedPassportElementPhoneNumber:
					goto handle_PhoneNumber

				case ffjtEncryptedPassportElementEmail:
					goto handle_Email

				case ffjtEncryptedPassportElementFiles:
					goto handle_Files

				case ffjtEncryptedPassportElementFrontSide:
					goto handle_FrontSide

				case ffjtEncryptedPassportElementReverseSide:
					goto handle_ReverseSide

				case ffjtEncryptedPassportElementSelfie:
					goto handle_Selfie

				case ffjtEncryptedPassportElementTranslation:
					goto handle_Translation

				case ffjtEncryptedPassportElementHash:
					goto handle_Hash

				case ffjtEncryptedPassportElementnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: j.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: j.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Files:

	/* handler: j.Files type=[]*model.PassportFile kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Files = nil
		} else {

			j.Files = []*PassportFile{}

			wantVal := true

			for {

				var tmpJFiles *PassportFile

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJFiles type=*model.PassportFile kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJFiles = nil

					} else {

						if tmpJFiles == nil {
							tmpJFiles = new(PassportFile)
						}

						err = tmpJFiles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Files = append(j.Files, tmpJFiles)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrontSide:

	/* handler: j.FrontSide type=model.PassportFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.FrontSide = nil

		} else {

			if j.FrontSide == nil {
				j.FrontSide = new(PassportFile)
			}

			err = j.FrontSide.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReverseSide:

	/* handler: j.ReverseSide type=model.PassportFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReverseSide = nil

		} else {

			if j.ReverseSide == nil {
				j.ReverseSide = new(PassportFile)
			}

			err = j.ReverseSide.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selfie:

	/* handler: j.Selfie type=model.PassportFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Selfie = nil

		} else {

			if j.Selfie == nil {
				j.Selfie = new(PassportFile)
			}

			err = j.Selfie.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Translation:

	/* handler: j.Translation type=[]*model.PassportFile kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Translation = nil
		} else {

			j.Translation = []*PassportFile{}

			wantVal := true

			for {

				var tmpJTranslation *PassportFile

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJTranslation type=*model.PassportFile kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJTranslation = nil

					} else {

						if tmpJTranslation == nil {
							tmpJTranslation = new(PassportFile)
						}

						err = tmpJTranslation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Translation = append(j.Translation, tmpJTranslation)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hash:

	/* handler: j.Hash type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Hash = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *File) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *File) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	if len(j.FilePath) != 0 {
		buf.WriteString(`"file_path":`)
		fflib.WriteJsonString(buf, string(j.FilePath))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFilebase = iota
	ffjtFilenosuchkey

	ffjtFileFileID

	ffjtFileFileUniqueID

	ffjtFileFileSize

	ffjtFileFilePath
)

var ffjKeyFileFileID = []byte("file_id")

var ffjKeyFileFileUniqueID = []byte("file_unique_id")

var ffjKeyFileFileSize = []byte("file_size")

var ffjKeyFileFilePath = []byte("file_path")

// UnmarshalJSON umarshall json - template of ffjson
func (j *File) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *File) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyFileFileID, kn) {
						currentKey = ffjtFileFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFileFileUniqueID, kn) {
						currentKey = ffjtFileFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFileFileSize, kn) {
						currentKey = ffjtFileFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFileFilePath, kn) {
						currentKey = ffjtFileFilePath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyFileFilePath, kn) {
					currentKey = ffjtFileFilePath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFileFileSize, kn) {
					currentKey = ffjtFileFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyFileFileUniqueID, kn) {
					currentKey = ffjtFileFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyFileFileID, kn) {
					currentKey = ffjtFileFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFileFileID:
					goto handle_FileID

				case ffjtFileFileUniqueID:
					goto handle_FileUniqueID

				case ffjtFileFileSize:
					goto handle_FileSize

				case ffjtFileFilePath:
					goto handle_FilePath

				case ffjtFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FilePath:

	/* handler: j.FilePath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FilePath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Game) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Game) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"photo":`)
	if j.Photo != nil {
		buf.WriteString(`[`)
		for i, v := range j.Photo {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				if v == nil {
					buf.WriteString("null")
				} else {

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(j.Text) != 0 {
		buf.WriteString(`"text":`)
		fflib.WriteJsonString(buf, string(j.Text))
		buf.WriteByte(',')
	}
	buf.WriteString(`"text_entities":`)
	if j.TextEntities != nil {
		buf.WriteString(`[`)
		for i, v := range j.TextEntities {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				if v == nil {
					buf.WriteString("null")
				} else {

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.Animation != nil {
		if true {
			buf.WriteString(`"animation":`)

			{

				err = j.Animation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGamebase = iota
	ffjtGamenosuchkey

	ffjtGameTitle

	ffjtGameDescription

	ffjtGamePhoto

	ffjtGameText

	ffjtGameTextEntities

	ffjtGameAnimation
)

var ffjKeyGameTitle = []byte("title")

var ffjKeyGameDescription = []byte("description")

var ffjKeyGamePhoto = []byte("photo")

var ffjKeyGameText = []byte("text")

var ffjKeyGameTextEntities = []byte("text_entities")

var ffjKeyGameAnimation = []byte("animation")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Game) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Game) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGameAnimation, kn) {
						currentKey = ffjtGameAnimation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyGameDescription, kn) {
						currentKey = ffjtGameDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGamePhoto, kn) {
						currentKey = ffjtGamePhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyGameTitle, kn) {
						currentKey = ffjtGameTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGameText, kn) {
						currentKey = ffjtGameText
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGameTextEntities, kn) {
						currentKey = ffjtGameTextEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGameAnimation, kn) {
					currentKey = ffjtGameAnimation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGameTextEntities, kn) {
					currentKey = ffjtGameTextEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGameText, kn) {
					currentKey = ffjtGameText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGamePhoto, kn) {
					currentKey = ffjtGamePhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGameDescription, kn) {
					currentKey = ffjtGameDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGameTitle, kn) {
					currentKey = ffjtGameTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGameTitle:
					goto handle_Title

				case ffjtGameDescription:
					goto handle_Description

				case ffjtGamePhoto:
					goto handle_Photo

				case ffjtGameText:
					goto handle_Text

				case ffjtGameTextEntities:
					goto handle_TextEntities

				case ffjtGameAnimation:
					goto handle_Animation

				case ffjtGamenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=[]*model.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Photo = nil
		} else {

			j.Photo = []*PhotoSize{}

			wantVal := true

			for {

				var tmpJPhoto *PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPhoto type=*model.PhotoSize kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJPhoto = nil

					} else {

						if tmpJPhoto == nil {
							tmpJPhoto = new(PhotoSize)
						}

						err = tmpJPhoto.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Photo = append(j.Photo, tmpJPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TextEntities:

	/* handler: j.TextEntities type=[]*model.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.TextEntities = nil
		} else {

			j.TextEntities = []*MessageEntity{}

			wantVal := true

			for {

				var tmpJTextEntities *MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJTextEntities type=*model.MessageEntity kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJTextEntities = nil

					} else {

						if tmpJTextEntities == nil {
							tmpJTextEntities = new(MessageEntity)
						}

						err = tmpJTextEntities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.TextEntities = append(j.TextEntities, tmpJTextEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Animation:

	/* handler: j.Animation type=model.Animation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Animation = nil

		} else {

			if j.Animation == nil {
				j.Animation = new(Animation)
			}

			err = j.Animation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineKeyboardButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	if len(j.CallbackData) != 0 {
		buf.WriteString(`"callback_data":`)
		fflib.WriteJsonString(buf, string(j.CallbackData))
		buf.WriteByte(',')
	}
	if j.WebApp != nil {
		if true {
			buf.WriteString(`"web_app":`)

			{

				err = j.WebApp.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.LoginURL != nil {
		if true {
			buf.WriteString(`"login_url":`)

			{

				err = j.LoginURL.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.SwitchInlineQuery) != 0 {
		buf.WriteString(`"switch_inline_query":`)
		fflib.WriteJsonString(buf, string(j.SwitchInlineQuery))
		buf.WriteByte(',')
	}
	if len(j.SwitchInlineQueryCurrentChat) != 0 {
		buf.WriteString(`"switch_inline_query_current_chat":`)
		fflib.WriteJsonString(buf, string(j.SwitchInlineQueryCurrentChat))
		buf.WriteByte(',')
	}
	if j.CallbackGame != nil {
		if true {
			buf.WriteString(`"callback_game":`)

			{

				err = j.CallbackGame.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Pay != false {
		if j.Pay {
			buf.WriteString(`"pay":true`)
		} else {
			buf.WriteString(`"pay":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineKeyboardButtonbase = iota
	ffjtInlineKeyboardButtonnosuchkey

	ffjtInlineKeyboardButtonText

	ffjtInlineKeyboardButtonURL

	ffjtInlineKeyboardButtonCallbackData

	ffjtInlineKeyboardButtonWebApp

	ffjtInlineKeyboardButtonLoginURL

	ffjtInlineKeyboardButtonSwitchInlineQuery

	ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat

	ffjtInlineKeyboardButtonCallbackGame

	ffjtInlineKeyboardButtonPay
)

var ffjKeyInlineKeyboardButtonText = []byte("text")

var ffjKeyInlineKeyboardButtonURL = []byte("url")

var ffjKeyInlineKeyboardButtonCallbackData = []byte("callback_data")

var ffjKeyInlineKeyboardButtonWebApp = []byte("web_app")

var ffjKeyInlineKeyboardButtonLoginURL = []byte("login_url")

var ffjKeyInlineKeyboardButtonSwitchInlineQuery = []byte("switch_inline_query")

var ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat = []byte("switch_inline_query_current_chat")

var ffjKeyInlineKeyboardButtonCallbackGame = []byte("callback_game")

var ffjKeyInlineKeyboardButtonPay = []byte("pay")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineKeyboardButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineKeyboardButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineKeyboardButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineKeyboardButtonCallbackData, kn) {
						currentKey = ffjtInlineKeyboardButtonCallbackData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonCallbackGame, kn) {
						currentKey = ffjtInlineKeyboardButtonCallbackGame
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineKeyboardButtonLoginURL, kn) {
						currentKey = ffjtInlineKeyboardButtonLoginURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineKeyboardButtonPay, kn) {
						currentKey = ffjtInlineKeyboardButtonPay
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInlineKeyboardButtonSwitchInlineQuery, kn) {
						currentKey = ffjtInlineKeyboardButtonSwitchInlineQuery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat, kn) {
						currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineKeyboardButtonText, kn) {
						currentKey = ffjtInlineKeyboardButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyInlineKeyboardButtonURL, kn) {
						currentKey = ffjtInlineKeyboardButtonURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyInlineKeyboardButtonWebApp, kn) {
						currentKey = ffjtInlineKeyboardButtonWebApp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonPay, kn) {
					currentKey = ffjtInlineKeyboardButtonPay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonCallbackGame, kn) {
					currentKey = ffjtInlineKeyboardButtonCallbackGame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat, kn) {
					currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonSwitchInlineQuery, kn) {
					currentKey = ffjtInlineKeyboardButtonSwitchInlineQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineKeyboardButtonLoginURL, kn) {
					currentKey = ffjtInlineKeyboardButtonLoginURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineKeyboardButtonWebApp, kn) {
					currentKey = ffjtInlineKeyboardButtonWebApp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonCallbackData, kn) {
					currentKey = ffjtInlineKeyboardButtonCallbackData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonURL, kn) {
					currentKey = ffjtInlineKeyboardButtonURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonText, kn) {
					currentKey = ffjtInlineKeyboardButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineKeyboardButtonText:
					goto handle_Text

				case ffjtInlineKeyboardButtonURL:
					goto handle_URL

				case ffjtInlineKeyboardButtonCallbackData:
					goto handle_CallbackData

				case ffjtInlineKeyboardButtonWebApp:
					goto handle_WebApp

				case ffjtInlineKeyboardButtonLoginURL:
					goto handle_LoginURL

				case ffjtInlineKeyboardButtonSwitchInlineQuery:
					goto handle_SwitchInlineQuery

				case ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat:
					goto handle_SwitchInlineQueryCurrentChat

				case ffjtInlineKeyboardButtonCallbackGame:
					goto handle_CallbackGame

				case ffjtInlineKeyboardButtonPay:
					goto handle_Pay

				case ffjtInlineKeyboardButtonnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackData:

	/* handler: j.CallbackData type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CallbackData = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WebApp:

	/* handler: j.WebApp type=model.WebAppInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.WebApp = nil

		} else {

			if j.WebApp == nil {
				j.WebApp = new(WebAppInfo)
			}

			err = j.WebApp.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LoginURL:

	/* handler: j.LoginURL type=model.LoginURL kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.LoginURL = nil

		} else {

			if j.LoginURL == nil {
				j.LoginURL = new(LoginURL)
			}

			err = j.LoginURL.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQuery:

	/* handler: j.SwitchInlineQuery type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SwitchInlineQuery = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQueryCurrentChat:

	/* handler: j.SwitchInlineQueryCurrentChat type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SwitchInlineQueryCurrentChat = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackGame:

	/* handler: j.CallbackGame type=model.CallbackGame kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CallbackGame = nil

		} else {

			if j.CallbackGame == nil {
				j.CallbackGame = new(CallbackGame)
			}

			err = j.CallbackGame.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pay:

	/* handler: j.Pay type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Pay = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Pay = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineKeyboardMarkup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"inline_keyboard":`)
	if j.InlineKeyboard != nil {
		buf.WriteString(`[`)
		for i, v := range j.InlineKeyboard {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						if v == nil {
							buf.WriteString("null")
						} else {

							err = v.MarshalJSONBuf(buf)
							if err != nil {
								return err
							}

						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineKeyboardMarkupbase = iota
	ffjtInlineKeyboardMarkupnosuchkey

	ffjtInlineKeyboardMarkupInlineKeyboard
)

var ffjKeyInlineKeyboardMarkupInlineKeyboard = []byte("inline_keyboard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineKeyboardMarkup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineKeyboardMarkup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineKeyboardMarkupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineKeyboardMarkupInlineKeyboard, kn) {
						currentKey = ffjtInlineKeyboardMarkupInlineKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardMarkupInlineKeyboard, kn) {
					currentKey = ffjtInlineKeyboardMarkupInlineKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineKeyboardMarkupInlineKeyboard:
					goto handle_InlineKeyboard

				case ffjtInlineKeyboardMarkupnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InlineKeyboard:

	/* handler: j.InlineKeyboard type=[][]*model.InlineKeyboardButton kind=slice quoted=false*/

	{
		/* Falling back. type=[][]*model.InlineKeyboardButton kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InlineKeyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteString(`,"query":`)
	fflib.WriteJsonString(buf, string(j.Query))
	buf.WriteString(`,"offset":`)
	fflib.WriteJsonString(buf, string(j.Offset))
	buf.WriteByte(',')
	if len(j.ChatType) != 0 {
		buf.WriteString(`"chat_type":`)
		fflib.WriteJsonString(buf, string(j.ChatType))
		buf.WriteByte(',')
	}
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQuerybase = iota
	ffjtInlineQuerynosuchkey

	ffjtInlineQueryID

	ffjtInlineQueryFrom

	ffjtInlineQueryQuery

	ffjtInlineQueryOffset

	ffjtInlineQueryChatType

	ffjtInlineQueryLocation
)

var ffjKeyInlineQueryID = []byte("id")

var ffjKeyInlineQueryFrom = []byte("from")

var ffjKeyInlineQueryQuery = []byte("query")

var ffjKeyInlineQueryOffset = []byte("offset")

var ffjKeyInlineQueryChatType = []byte("chat_type")

var ffjKeyInlineQueryLocation = []byte("location")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryChatType, kn) {
						currentKey = ffjtInlineQueryChatType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyInlineQueryFrom, kn) {
						currentKey = ffjtInlineQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryID, kn) {
						currentKey = ffjtInlineQueryID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryLocation, kn) {
						currentKey = ffjtInlineQueryLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyInlineQueryOffset, kn) {
						currentKey = ffjtInlineQueryOffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyInlineQueryQuery, kn) {
						currentKey = ffjtInlineQueryQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryLocation, kn) {
					currentKey = ffjtInlineQueryLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryChatType, kn) {
					currentKey = ffjtInlineQueryChatType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryOffset, kn) {
					currentKey = ffjtInlineQueryOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryQuery, kn) {
					currentKey = ffjtInlineQueryQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryFrom, kn) {
					currentKey = ffjtInlineQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryID, kn) {
					currentKey = ffjtInlineQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryID:
					goto handle_ID

				case ffjtInlineQueryFrom:
					goto handle_From

				case ffjtInlineQueryQuery:
					goto handle_Query

				case ffjtInlineQueryOffset:
					goto handle_Offset

				case ffjtInlineQueryChatType:
					goto handle_ChatType

				case ffjtInlineQueryLocation:
					goto handle_Location

				case ffjtInlineQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: j.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: j.Offset type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Offset = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatType:

	/* handler: j.ChatType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ChatType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=model.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Invoice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Invoice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"start_parameter":`)
	fflib.WriteJsonString(buf, string(j.StartParameter))
	buf.WriteString(`,"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"total_amount":`)
	fflib.FormatBits2(buf, uint64(j.TotalAmount), 10, j.TotalAmount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInvoicebase = iota
	ffjtInvoicenosuchkey

	ffjtInvoiceTitle

	ffjtInvoiceDescription

	ffjtInvoiceStartParameter

	ffjtInvoiceCurrency

	ffjtInvoiceTotalAmount
)

var ffjKeyInvoiceTitle = []byte("title")

var ffjKeyInvoiceDescription = []byte("description")

var ffjKeyInvoiceStartParameter = []byte("start_parameter")

var ffjKeyInvoiceCurrency = []byte("currency")

var ffjKeyInvoiceTotalAmount = []byte("total_amount")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Invoice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Invoice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInvoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInvoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInvoiceCurrency, kn) {
						currentKey = ffjtInvoiceCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInvoiceDescription, kn) {
						currentKey = ffjtInvoiceDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInvoiceStartParameter, kn) {
						currentKey = ffjtInvoiceStartParameter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInvoiceTitle, kn) {
						currentKey = ffjtInvoiceTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceTotalAmount, kn) {
						currentKey = ffjtInvoiceTotalAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceTotalAmount, kn) {
					currentKey = ffjtInvoiceTotalAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInvoiceCurrency, kn) {
					currentKey = ffjtInvoiceCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceStartParameter, kn) {
					currentKey = ffjtInvoiceStartParameter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceDescription, kn) {
					currentKey = ffjtInvoiceDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInvoiceTitle, kn) {
					currentKey = ffjtInvoiceTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInvoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInvoiceTitle:
					goto handle_Title

				case ffjtInvoiceDescription:
					goto handle_Description

				case ffjtInvoiceStartParameter:
					goto handle_StartParameter

				case ffjtInvoiceCurrency:
					goto handle_Currency

				case ffjtInvoiceTotalAmount:
					goto handle_TotalAmount

				case ffjtInvoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartParameter:

	/* handler: j.StartParameter type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StartParameter = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAmount:

	/* handler: j.TotalAmount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalAmount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Location) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Location) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 64)
	buf.WriteString(`,"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 64)
	buf.WriteByte(',')
	if j.HorizontalAccuracy != 0 {
		buf.WriteString(`"horizontal_accuracy":`)
		fflib.AppendFloat(buf, float64(j.HorizontalAccuracy), 'g', -1, 32)
		buf.WriteByte(',')
	}
	if j.LivePeriod != 0 {
		buf.WriteString(`"live_period":`)
		fflib.FormatBits2(buf, uint64(j.LivePeriod), 10, j.LivePeriod < 0)
		buf.WriteByte(',')
	}
	if j.Heading != 0 {
		buf.WriteString(`"heading":`)
		fflib.FormatBits2(buf, uint64(j.Heading), 10, j.Heading < 0)
		buf.WriteByte(',')
	}
	if j.ProximityAlertRadius != 0 {
		buf.WriteString(`"proximity_alert_radius":`)
		fflib.FormatBits2(buf, uint64(j.ProximityAlertRadius), 10, j.ProximityAlertRadius < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLocationbase = iota
	ffjtLocationnosuchkey

	ffjtLocationLongitude

	ffjtLocationLatitude

	ffjtLocationHorizontalAccuracy

	ffjtLocationLivePeriod

	ffjtLocationHeading

	ffjtLocationProximityAlertRadius
)

var ffjKeyLocationLongitude = []byte("longitude")

var ffjKeyLocationLatitude = []byte("latitude")

var ffjKeyLocationHorizontalAccuracy = []byte("horizontal_accuracy")

var ffjKeyLocationLivePeriod = []byte("live_period")

var ffjKeyLocationHeading = []byte("heading")

var ffjKeyLocationProximityAlertRadius = []byte("proximity_alert_radius")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Location) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Location) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffjKeyLocationHorizontalAccuracy, kn) {
						currentKey = ffjtLocationHorizontalAccuracy
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyLocationHeading, kn) {
						currentKey = ffjtLocationHeading
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyLocationLongitude, kn) {
						currentKey = ffjtLocationLongitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyLocationLatitude, kn) {
						currentKey = ffjtLocationLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyLocationLivePeriod, kn) {
						currentKey = ffjtLocationLivePeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyLocationProximityAlertRadius, kn) {
						currentKey = ffjtLocationProximityAlertRadius
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyLocationProximityAlertRadius, kn) {
					currentKey = ffjtLocationProximityAlertRadius
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLocationHeading, kn) {
					currentKey = ffjtLocationHeading
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyLocationLivePeriod, kn) {
					currentKey = ffjtLocationLivePeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyLocationHorizontalAccuracy, kn) {
					currentKey = ffjtLocationHorizontalAccuracy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLocationLatitude, kn) {
					currentKey = ffjtLocationLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLocationLongitude, kn) {
					currentKey = ffjtLocationLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLocationLongitude:
					goto handle_Longitude

				case ffjtLocationLatitude:
					goto handle_Latitude

				case ffjtLocationHorizontalAccuracy:
					goto handle_HorizontalAccuracy

				case ffjtLocationLivePeriod:
					goto handle_LivePeriod

				case ffjtLocationHeading:
					goto handle_Heading

				case ffjtLocationProximityAlertRadius:
					goto handle_ProximityAlertRadius

				case ffjtLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Longitude:

	/* handler: j.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: j.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HorizontalAccuracy:

	/* handler: j.HorizontalAccuracy type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.HorizontalAccuracy = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LivePeriod:

	/* handler: j.LivePeriod type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.LivePeriod = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Heading:

	/* handler: j.Heading type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Heading = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProximityAlertRadius:

	/* handler: j.ProximityAlertRadius type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ProximityAlertRadius = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *LoginURL) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *LoginURL) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteByte(',')
	if len(j.ForwardText) != 0 {
		buf.WriteString(`"forward_text":`)
		fflib.WriteJsonString(buf, string(j.ForwardText))
		buf.WriteByte(',')
	}
	if len(j.BotUsername) != 0 {
		buf.WriteString(`"bot_username":`)
		fflib.WriteJsonString(buf, string(j.BotUsername))
		buf.WriteByte(',')
	}
	if j.RequestWriteAccess != false {
		if j.RequestWriteAccess {
			buf.WriteString(`"request_write_access":true`)
		} else {
			buf.WriteString(`"request_write_access":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLoginURLbase = iota
	ffjtLoginURLnosuchkey

	ffjtLoginURLURL

	ffjtLoginURLForwardText

	ffjtLoginURLBotUsername

	ffjtLoginURLRequestWriteAccess
)

var ffjKeyLoginURLURL = []byte("url")

var ffjKeyLoginURLForwardText = []byte("forward_text")

var ffjKeyLoginURLBotUsername = []byte("bot_username")

var ffjKeyLoginURLRequestWriteAccess = []byte("request_write_access")

// UnmarshalJSON umarshall json - template of ffjson
func (j *LoginURL) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *LoginURL) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLoginURLbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLoginURLnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyLoginURLBotUsername, kn) {
						currentKey = ffjtLoginURLBotUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyLoginURLForwardText, kn) {
						currentKey = ffjtLoginURLForwardText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyLoginURLRequestWriteAccess, kn) {
						currentKey = ffjtLoginURLRequestWriteAccess
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyLoginURLURL, kn) {
						currentKey = ffjtLoginURLURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyLoginURLRequestWriteAccess, kn) {
					currentKey = ffjtLoginURLRequestWriteAccess
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyLoginURLBotUsername, kn) {
					currentKey = ffjtLoginURLBotUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyLoginURLForwardText, kn) {
					currentKey = ffjtLoginURLForwardText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLoginURLURL, kn) {
					currentKey = ffjtLoginURLURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLoginURLnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLoginURLURL:
					goto handle_URL

				case ffjtLoginURLForwardText:
					goto handle_ForwardText

				case ffjtLoginURLBotUsername:
					goto handle_BotUsername

				case ffjtLoginURLRequestWriteAccess:
					goto handle_RequestWriteAccess

				case ffjtLoginURLnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardText:

	/* handler: j.ForwardText type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ForwardText = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BotUsername:

	/* handler: j.BotUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BotUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestWriteAccess:

	/* handler: j.RequestWriteAccess type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestWriteAccess = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestWriteAccess = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MaskPosition) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MaskPosition) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"point":`)
	fflib.WriteJsonString(buf, string(j.Point))
	buf.WriteString(`,"x_shift":`)
	fflib.AppendFloat(buf, float64(j.XShift), 'g', -1, 32)
	buf.WriteString(`,"y_shift":`)
	fflib.AppendFloat(buf, float64(j.YShift), 'g', -1, 32)
	buf.WriteString(`,"scale":`)
	fflib.AppendFloat(buf, float64(j.Scale), 'g', -1, 32)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMaskPositionbase = iota
	ffjtMaskPositionnosuchkey

	ffjtMaskPositionPoint

	ffjtMaskPositionXShift

	ffjtMaskPositionYShift

	ffjtMaskPositionScale
)

var ffjKeyMaskPositionPoint = []byte("point")

var ffjKeyMaskPositionXShift = []byte("x_shift")

var ffjKeyMaskPositionYShift = []byte("y_shift")

var ffjKeyMaskPositionScale = []byte("scale")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MaskPosition) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MaskPosition) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMaskPositionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMaskPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffjKeyMaskPositionPoint, kn) {
						currentKey = ffjtMaskPositionPoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMaskPositionScale, kn) {
						currentKey = ffjtMaskPositionScale
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'x':

					if bytes.Equal(ffjKeyMaskPositionXShift, kn) {
						currentKey = ffjtMaskPositionXShift
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'y':

					if bytes.Equal(ffjKeyMaskPositionYShift, kn) {
						currentKey = ffjtMaskPositionYShift
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMaskPositionScale, kn) {
					currentKey = ffjtMaskPositionScale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMaskPositionYShift, kn) {
					currentKey = ffjtMaskPositionYShift
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMaskPositionXShift, kn) {
					currentKey = ffjtMaskPositionXShift
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMaskPositionPoint, kn) {
					currentKey = ffjtMaskPositionPoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMaskPositionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMaskPositionPoint:
					goto handle_Point

				case ffjtMaskPositionXShift:
					goto handle_XShift

				case ffjtMaskPositionYShift:
					goto handle_YShift

				case ffjtMaskPositionScale:
					goto handle_Scale

				case ffjtMaskPositionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Point:

	/* handler: j.Point type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Point = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_XShift:

	/* handler: j.XShift type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.XShift = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_YShift:

	/* handler: j.YShift type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.YShift = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scale:

	/* handler: j.Scale type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Scale = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Message) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Message) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "message_id":`)
	fflib.FormatBits2(buf, uint64(j.MessageID), 10, j.MessageID < 0)
	buf.WriteByte(',')
	if j.From != nil {
		if true {
			buf.WriteString(`"from":`)

			{

				err = j.From.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.SenderChat != nil {
		if true {
			buf.WriteString(`"sender_chat":`)

			{

				err = j.SenderChat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"date":`)
	fflib.FormatBits2(buf, uint64(j.Date), 10, j.Date < 0)
	if j.Chat != nil {
		buf.WriteString(`,"chat":`)

		{

			err = j.Chat.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"chat":null`)
	}
	buf.WriteByte(',')
	if j.ForwardFrom != nil {
		if true {
			buf.WriteString(`"forward_from":`)

			{

				err = j.ForwardFrom.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ForwardFromChat != nil {
		if true {
			buf.WriteString(`"forward_from_chat":`)

			{

				err = j.ForwardFromChat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ForwardFromMessageID != 0 {
		buf.WriteString(`"forward_from_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ForwardFromMessageID), 10, j.ForwardFromMessageID < 0)
		buf.WriteByte(',')
	}
	if len(j.ForwardSignature) != 0 {
		buf.WriteString(`"forward_signature":`)
		fflib.WriteJsonString(buf, string(j.ForwardSignature))
		buf.WriteByte(',')
	}
	if len(j.ForwardSenderName) != 0 {
		buf.WriteString(`"forward_sender_name":`)
		fflib.WriteJsonString(buf, string(j.ForwardSenderName))
		buf.WriteByte(',')
	}
	if j.ForwardDate != 0 {
		buf.WriteString(`"forward_date":`)
		fflib.FormatBits2(buf, uint64(j.ForwardDate), 10, j.ForwardDate < 0)
		buf.WriteByte(',')
	}
	if j.IsAutomaticForward != false {
		if j.IsAutomaticForward {
			buf.WriteString(`"is_automatic_forward":true`)
		} else {
			buf.WriteString(`"is_automatic_forward":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyToMessage != nil {
		if true {
			buf.WriteString(`"reply_to_message":`)

			{

				err = j.ReplyToMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ViaBot != nil {
		if true {
			buf.WriteString(`"via_bot":`)

			{

				err = j.ViaBot.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.EditDate != 0 {
		buf.WriteString(`"edit_date":`)
		fflib.FormatBits2(buf, uint64(j.EditDate), 10, j.EditDate < 0)
		buf.WriteByte(',')
	}
	if j.HasProtectedContent != false {
		if j.HasProtectedContent {
			buf.WriteString(`"has_protected_content":true`)
		} else {
			buf.WriteString(`"has_protected_content":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.MediaGroupID) != 0 {
		buf.WriteString(`"media_group_id":`)
		fflib.WriteJsonString(buf, string(j.MediaGroupID))
		buf.WriteByte(',')
	}
	if len(j.AuthorSignature) != 0 {
		buf.WriteString(`"author_signature":`)
		fflib.WriteJsonString(buf, string(j.AuthorSignature))
		buf.WriteByte(',')
	}
	if len(j.Text) != 0 {
		buf.WriteString(`"text":`)
		fflib.WriteJsonString(buf, string(j.Text))
		buf.WriteByte(',')
	}
	if len(j.Entities) != 0 {
		buf.WriteString(`"entities":`)
		if j.Entities != nil {
			buf.WriteString(`[`)
			for i, v := range j.Entities {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Animation != nil {
		if true {
			buf.WriteString(`"animation":`)

			{

				err = j.Animation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Audio != nil {
		if true {
			buf.WriteString(`"audio":`)

			{

				err = j.Audio.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Document != nil {
		if true {
			buf.WriteString(`"document":`)

			{

				err = j.Document.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Photo) != 0 {
		buf.WriteString(`"photo":`)
		if j.Photo != nil {
			buf.WriteString(`[`)
			for i, v := range j.Photo {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Sticker != nil {
		if true {
			buf.WriteString(`"sticker":`)

			{

				err = j.Sticker.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Video != nil {
		if true {
			buf.WriteString(`"video":`)

			{

				err = j.Video.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.VideoNote != nil {
		if true {
			buf.WriteString(`"video_note":`)

			{

				err = j.VideoNote.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Voice != nil {
		if true {
			buf.WriteString(`"voice":`)

			{

				err = j.Voice.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if len(j.CaptionEntities) != 0 {
		buf.WriteString(`"caption_entities":`)
		if j.CaptionEntities != nil {
			buf.WriteString(`[`)
			for i, v := range j.CaptionEntities {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Contact != nil {
		if true {
			buf.WriteString(`"contact":`)

			{

				err = j.Contact.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Dice != nil {
		if true {
			buf.WriteString(`"dice":`)

			{

				err = j.Dice.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Game != nil {
		if true {
			buf.WriteString(`"game":`)

			{

				err = j.Game.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Poll != nil {
		if true {
			buf.WriteString(`"poll":`)

			{

				err = j.Poll.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Venue != nil {
		if true {
			buf.WriteString(`"venue":`)

			{

				err = j.Venue.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = j.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.NewChatMembers) != 0 {
		buf.WriteString(`"new_chat_members":`)
		if j.NewChatMembers != nil {
			buf.WriteString(`[`)
			for i, v := range j.NewChatMembers {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.LeftChatMember != nil {
		if true {
			buf.WriteString(`"left_chat_member":`)

			{

				err = j.LeftChatMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.NewChatTitle) != 0 {
		buf.WriteString(`"new_chat_title":`)
		fflib.WriteJsonString(buf, string(j.NewChatTitle))
		buf.WriteByte(',')
	}
	if len(j.NewChatPhoto) != 0 {
		buf.WriteString(`"new_chat_photo":`)
		if j.NewChatPhoto != nil {
			buf.WriteString(`[`)
			for i, v := range j.NewChatPhoto {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.DeleteChatPhoto != false {
		if j.DeleteChatPhoto {
			buf.WriteString(`"delete_chat_photo":true`)
		} else {
			buf.WriteString(`"delete_chat_photo":false`)
		}
		buf.WriteByte(',')
	}
	if j.GroupChatCreated != false {
		if j.GroupChatCreated {
			buf.WriteString(`"group_chat_created":true`)
		} else {
			buf.WriteString(`"group_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.SupergroupChatCreated != false {
		if j.SupergroupChatCreated {
			buf.WriteString(`"supergroup_chat_created":true`)
		} else {
			buf.WriteString(`"supergroup_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.ChannelChatCreated != false {
		if j.ChannelChatCreated {
			buf.WriteString(`"channel_chat_created":true`)
		} else {
			buf.WriteString(`"channel_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.MessageAutoDeleteTimerChanged != nil {
		if true {
			buf.WriteString(`"message_auto_delete_timer_changed":`)

			{

				err = j.MessageAutoDeleteTimerChanged.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.MigrateToChatID != 0 {
		buf.WriteString(`"migrate_to_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.MigrateToChatID), 10, j.MigrateToChatID < 0)
		buf.WriteByte(',')
	}
	if j.MigrateFromChatID != 0 {
		buf.WriteString(`"migrate_from_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.MigrateFromChatID), 10, j.MigrateFromChatID < 0)
		buf.WriteByte(',')
	}
	if j.PinnedMessage != nil {
		if true {
			buf.WriteString(`"pinned_message":`)

			{

				err = j.PinnedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Invoice != nil {
		if true {
			buf.WriteString(`"invoice":`)

			{

				err = j.Invoice.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.SuccessfulPayment != nil {
		if true {
			buf.WriteString(`"successful_payment":`)

			{

				err = j.SuccessfulPayment.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.ConnectedWebsite) != 0 {
		buf.WriteString(`"connected_website":`)
		fflib.WriteJsonString(buf, string(j.ConnectedWebsite))
		buf.WriteByte(',')
	}
	if j.PassportData != nil {
		if true {
			buf.WriteString(`"passport_data":`)

			{

				err = j.PassportData.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ProximityAlertTriggered != nil {
		if true {
			buf.WriteString(`"proximity_alert_triggered":`)

			{

				err = j.ProximityAlertTriggered.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.VideoChatScheduled != nil {
		if true {
			buf.WriteString(`"video_chat_scheduled":`)

			{

				err = j.VideoChatScheduled.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.VideoChatStarted != nil {
		if true {
			buf.WriteString(`"video_chat_started":`)

			{

				err = j.VideoChatStarted.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.VideoChatEnded != nil {
		if true {
			buf.WriteString(`"video_chat_ended":`)

			{

				err = j.VideoChatEnded.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.VideoChatParticipantsInvited != nil {
		if true {
			buf.WriteString(`"video_chat_participants_invited":`)

			{

				err = j.VideoChatParticipantsInvited.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.WebAppData != nil {
		if true {
			buf.WriteString(`"web_app_data":`)

			{

				err = j.WebAppData.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = j.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessagebase = iota
	ffjtMessagenosuchkey

	ffjtMessageMessageID

	ffjtMessageFrom

	ffjtMessageSenderChat

	ffjtMessageDate

	ffjtMessageChat

	ffjtMessageForwardFrom

	ffjtMessageForwardFromChat

	ffjtMessageForwardFromMessageID

	ffjtMessageForwardSignature

	ffjtMessageForwardSenderName

	ffjtMessageForwardDate

	ffjtMessageIsAutomaticForward

	ffjtMessageReplyToMessage

	ffjtMessageViaBot

	ffjtMessageEditDate

	ffjtMessageHasProtectedContent

	ffjtMessageMediaGroupID

	ffjtMessageAuthorSignature

	ffjtMessageText

	ffjtMessageEntities

	ffjtMessageAnimation

	ffjtMessageAudio

	ffjtMessageDocument

	ffjtMessagePhoto

	ffjtMessageSticker

	ffjtMessageVideo

	ffjtMessageVideoNote

	ffjtMessageVoice

	ffjtMessageCaption

	ffjtMessageCaptionEntities

	ffjtMessageContact

	ffjtMessageDice

	ffjtMessageGame

	ffjtMessagePoll

	ffjtMessageVenue

	ffjtMessageLocation

	ffjtMessageNewChatMembers

	ffjtMessageLeftChatMember

	ffjtMessageNewChatTitle

	ffjtMessageNewChatPhoto

	ffjtMessageDeleteChatPhoto

	ffjtMessageGroupChatCreated

	ffjtMessageSupergroupChatCreated

	ffjtMessageChannelChatCreated

	ffjtMessageMessageAutoDeleteTimerChanged

	ffjtMessageMigrateToChatID

	ffjtMessageMigrateFromChatID

	ffjtMessagePinnedMessage

	ffjtMessageInvoice

	ffjtMessageSuccessfulPayment

	ffjtMessageConnectedWebsite

	ffjtMessagePassportData

	ffjtMessageProximityAlertTriggered

	ffjtMessageVideoChatScheduled

	ffjtMessageVideoChatStarted

	ffjtMessageVideoChatEnded

	ffjtMessageVideoChatParticipantsInvited

	ffjtMessageWebAppData

	ffjtMessageReplyMarkup
)

var ffjKeyMessageMessageID = []byte("message_id")

var ffjKeyMessageFrom = []byte("from")

var ffjKeyMessageSenderChat = []byte("sender_chat")

var ffjKeyMessageDate = []byte("date")

var ffjKeyMessageChat = []byte("chat")

var ffjKeyMessageForwardFrom = []byte("forward_from")

var ffjKeyMessageForwardFromChat = []byte("forward_from_chat")

var ffjKeyMessageForwardFromMessageID = []byte("forward_from_message_id")

var ffjKeyMessageForwardSignature = []byte("forward_signature")

var ffjKeyMessageForwardSenderName = []byte("forward_sender_name")

var ffjKeyMessageForwardDate = []byte("forward_date")

var ffjKeyMessageIsAutomaticForward = []byte("is_automatic_forward")

var ffjKeyMessageReplyToMessage = []byte("reply_to_message")

var ffjKeyMessageViaBot = []byte("via_bot")

var ffjKeyMessageEditDate = []byte("edit_date")

var ffjKeyMessageHasProtectedContent = []byte("has_protected_content")

var ffjKeyMessageMediaGroupID = []byte("media_group_id")

var ffjKeyMessageAuthorSignature = []byte("author_signature")

var ffjKeyMessageText = []byte("text")

var ffjKeyMessageEntities = []byte("entities")

var ffjKeyMessageAnimation = []byte("animation")

var ffjKeyMessageAudio = []byte("audio")

var ffjKeyMessageDocument = []byte("document")

var ffjKeyMessagePhoto = []byte("photo")

var ffjKeyMessageSticker = []byte("sticker")

var ffjKeyMessageVideo = []byte("video")

var ffjKeyMessageVideoNote = []byte("video_note")

var ffjKeyMessageVoice = []byte("voice")

var ffjKeyMessageCaption = []byte("caption")

var ffjKeyMessageCaptionEntities = []byte("caption_entities")

var ffjKeyMessageContact = []byte("contact")

var ffjKeyMessageDice = []byte("dice")

var ffjKeyMessageGame = []byte("game")

var ffjKeyMessagePoll = []byte("poll")

var ffjKeyMessageVenue = []byte("venue")

var ffjKeyMessageLocation = []byte("location")

var ffjKeyMessageNewChatMembers = []byte("new_chat_members")

var ffjKeyMessageLeftChatMember = []byte("left_chat_member")

var ffjKeyMessageNewChatTitle = []byte("new_chat_title")

var ffjKeyMessageNewChatPhoto = []byte("new_chat_photo")

var ffjKeyMessageDeleteChatPhoto = []byte("delete_chat_photo")

var ffjKeyMessageGroupChatCreated = []byte("group_chat_created")

var ffjKeyMessageSupergroupChatCreated = []byte("supergroup_chat_created")

var ffjKeyMessageChannelChatCreated = []byte("channel_chat_created")

var ffjKeyMessageMessageAutoDeleteTimerChanged = []byte("message_auto_delete_timer_changed")

var ffjKeyMessageMigrateToChatID = []byte("migrate_to_chat_id")

var ffjKeyMessageMigrateFromChatID = []byte("migrate_from_chat_id")

var ffjKeyMessagePinnedMessage = []byte("pinned_message")

var ffjKeyMessageInvoice = []byte("invoice")

var ffjKeyMessageSuccessfulPayment = []byte("successful_payment")

var ffjKeyMessageConnectedWebsite = []byte("connected_website")

var ffjKeyMessagePassportData = []byte("passport_data")

var ffjKeyMessageProximityAlertTriggered = []byte("proximity_alert_triggered")

var ffjKeyMessageVideoChatScheduled = []byte("video_chat_scheduled")

var ffjKeyMessageVideoChatStarted = []byte("video_chat_started")

var ffjKeyMessageVideoChatEnded = []byte("video_chat_ended")

var ffjKeyMessageVideoChatParticipantsInvited = []byte("video_chat_participants_invited")

var ffjKeyMessageWebAppData = []byte("web_app_data")

var ffjKeyMessageReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Message) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Message) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyMessageAuthorSignature, kn) {
						currentKey = ffjtMessageAuthorSignature
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageAnimation, kn) {
						currentKey = ffjtMessageAnimation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageAudio, kn) {
						currentKey = ffjtMessageAudio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyMessageChat, kn) {
						currentKey = ffjtMessageChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCaption, kn) {
						currentKey = ffjtMessageCaption
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCaptionEntities, kn) {
						currentKey = ffjtMessageCaptionEntities
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageContact, kn) {
						currentKey = ffjtMessageContact
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageChannelChatCreated, kn) {
						currentKey = ffjtMessageChannelChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageConnectedWebsite, kn) {
						currentKey = ffjtMessageConnectedWebsite
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyMessageDate, kn) {
						currentKey = ffjtMessageDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageDocument, kn) {
						currentKey = ffjtMessageDocument
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageDice, kn) {
						currentKey = ffjtMessageDice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageDeleteChatPhoto, kn) {
						currentKey = ffjtMessageDeleteChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageEditDate, kn) {
						currentKey = ffjtMessageEditDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageEntities, kn) {
						currentKey = ffjtMessageEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyMessageFrom, kn) {
						currentKey = ffjtMessageFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardFrom, kn) {
						currentKey = ffjtMessageForwardFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardFromChat, kn) {
						currentKey = ffjtMessageForwardFromChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardFromMessageID, kn) {
						currentKey = ffjtMessageForwardFromMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardSignature, kn) {
						currentKey = ffjtMessageForwardSignature
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardSenderName, kn) {
						currentKey = ffjtMessageForwardSenderName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardDate, kn) {
						currentKey = ffjtMessageForwardDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageGame, kn) {
						currentKey = ffjtMessageGame
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageGroupChatCreated, kn) {
						currentKey = ffjtMessageGroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyMessageHasProtectedContent, kn) {
						currentKey = ffjtMessageHasProtectedContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyMessageIsAutomaticForward, kn) {
						currentKey = ffjtMessageIsAutomaticForward
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageInvoice, kn) {
						currentKey = ffjtMessageInvoice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyMessageLocation, kn) {
						currentKey = ffjtMessageLocation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageLeftChatMember, kn) {
						currentKey = ffjtMessageLeftChatMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageMessageID, kn) {
						currentKey = ffjtMessageMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMediaGroupID, kn) {
						currentKey = ffjtMessageMediaGroupID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMessageAutoDeleteTimerChanged, kn) {
						currentKey = ffjtMessageMessageAutoDeleteTimerChanged
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMigrateToChatID, kn) {
						currentKey = ffjtMessageMigrateToChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMigrateFromChatID, kn) {
						currentKey = ffjtMessageMigrateFromChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMessageNewChatMembers, kn) {
						currentKey = ffjtMessageNewChatMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatTitle, kn) {
						currentKey = ffjtMessageNewChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatPhoto, kn) {
						currentKey = ffjtMessageNewChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyMessagePhoto, kn) {
						currentKey = ffjtMessagePhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessagePoll, kn) {
						currentKey = ffjtMessagePoll
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessagePinnedMessage, kn) {
						currentKey = ffjtMessagePinnedMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessagePassportData, kn) {
						currentKey = ffjtMessagePassportData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageProximityAlertTriggered, kn) {
						currentKey = ffjtMessageProximityAlertTriggered
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyMessageReplyToMessage, kn) {
						currentKey = ffjtMessageReplyToMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageReplyMarkup, kn) {
						currentKey = ffjtMessageReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMessageSenderChat, kn) {
						currentKey = ffjtMessageSenderChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageSticker, kn) {
						currentKey = ffjtMessageSticker
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageSupergroupChatCreated, kn) {
						currentKey = ffjtMessageSupergroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageSuccessfulPayment, kn) {
						currentKey = ffjtMessageSuccessfulPayment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageText, kn) {
						currentKey = ffjtMessageText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyMessageViaBot, kn) {
						currentKey = ffjtMessageViaBot
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVideo, kn) {
						currentKey = ffjtMessageVideo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVideoNote, kn) {
						currentKey = ffjtMessageVideoNote
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVoice, kn) {
						currentKey = ffjtMessageVoice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVenue, kn) {
						currentKey = ffjtMessageVenue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVideoChatScheduled, kn) {
						currentKey = ffjtMessageVideoChatScheduled
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVideoChatStarted, kn) {
						currentKey = ffjtMessageVideoChatStarted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVideoChatEnded, kn) {
						currentKey = ffjtMessageVideoChatEnded
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVideoChatParticipantsInvited, kn) {
						currentKey = ffjtMessageVideoChatParticipantsInvited
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyMessageWebAppData, kn) {
						currentKey = ffjtMessageWebAppData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessageReplyMarkup, kn) {
					currentKey = ffjtMessageReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageWebAppData, kn) {
					currentKey = ffjtMessageWebAppData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageVideoChatParticipantsInvited, kn) {
					currentKey = ffjtMessageVideoChatParticipantsInvited
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageVideoChatEnded, kn) {
					currentKey = ffjtMessageVideoChatEnded
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageVideoChatStarted, kn) {
					currentKey = ffjtMessageVideoChatStarted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageVideoChatScheduled, kn) {
					currentKey = ffjtMessageVideoChatScheduled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageProximityAlertTriggered, kn) {
					currentKey = ffjtMessageProximityAlertTriggered
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessagePassportData, kn) {
					currentKey = ffjtMessagePassportData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageConnectedWebsite, kn) {
					currentKey = ffjtMessageConnectedWebsite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSuccessfulPayment, kn) {
					currentKey = ffjtMessageSuccessfulPayment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageInvoice, kn) {
					currentKey = ffjtMessageInvoice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessagePinnedMessage, kn) {
					currentKey = ffjtMessagePinnedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMigrateFromChatID, kn) {
					currentKey = ffjtMessageMigrateFromChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMigrateToChatID, kn) {
					currentKey = ffjtMessageMigrateToChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageMessageAutoDeleteTimerChanged, kn) {
					currentKey = ffjtMessageMessageAutoDeleteTimerChanged
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageChannelChatCreated, kn) {
					currentKey = ffjtMessageChannelChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSupergroupChatCreated, kn) {
					currentKey = ffjtMessageSupergroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageGroupChatCreated, kn) {
					currentKey = ffjtMessageGroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageDeleteChatPhoto, kn) {
					currentKey = ffjtMessageDeleteChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatPhoto, kn) {
					currentKey = ffjtMessageNewChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatTitle, kn) {
					currentKey = ffjtMessageNewChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageLeftChatMember, kn) {
					currentKey = ffjtMessageLeftChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageNewChatMembers, kn) {
					currentKey = ffjtMessageNewChatMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageLocation, kn) {
					currentKey = ffjtMessageLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVenue, kn) {
					currentKey = ffjtMessageVenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessagePoll, kn) {
					currentKey = ffjtMessagePoll
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageGame, kn) {
					currentKey = ffjtMessageGame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDice, kn) {
					currentKey = ffjtMessageDice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageContact, kn) {
					currentKey = ffjtMessageContact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageCaptionEntities, kn) {
					currentKey = ffjtMessageCaptionEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCaption, kn) {
					currentKey = ffjtMessageCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVoice, kn) {
					currentKey = ffjtMessageVoice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageVideoNote, kn) {
					currentKey = ffjtMessageVideoNote
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVideo, kn) {
					currentKey = ffjtMessageVideo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSticker, kn) {
					currentKey = ffjtMessageSticker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessagePhoto, kn) {
					currentKey = ffjtMessagePhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDocument, kn) {
					currentKey = ffjtMessageDocument
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageAudio, kn) {
					currentKey = ffjtMessageAudio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageAnimation, kn) {
					currentKey = ffjtMessageAnimation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageEntities, kn) {
					currentKey = ffjtMessageEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageText, kn) {
					currentKey = ffjtMessageText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageAuthorSignature, kn) {
					currentKey = ffjtMessageAuthorSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMediaGroupID, kn) {
					currentKey = ffjtMessageMediaGroupID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageHasProtectedContent, kn) {
					currentKey = ffjtMessageHasProtectedContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageEditDate, kn) {
					currentKey = ffjtMessageEditDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageViaBot, kn) {
					currentKey = ffjtMessageViaBot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReplyToMessage, kn) {
					currentKey = ffjtMessageReplyToMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageIsAutomaticForward, kn) {
					currentKey = ffjtMessageIsAutomaticForward
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardDate, kn) {
					currentKey = ffjtMessageForwardDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageForwardSenderName, kn) {
					currentKey = ffjtMessageForwardSenderName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageForwardSignature, kn) {
					currentKey = ffjtMessageForwardSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageForwardFromMessageID, kn) {
					currentKey = ffjtMessageForwardFromMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardFromChat, kn) {
					currentKey = ffjtMessageForwardFromChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardFrom, kn) {
					currentKey = ffjtMessageForwardFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageChat, kn) {
					currentKey = ffjtMessageChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDate, kn) {
					currentKey = ffjtMessageDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSenderChat, kn) {
					currentKey = ffjtMessageSenderChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageFrom, kn) {
					currentKey = ffjtMessageFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageMessageID, kn) {
					currentKey = ffjtMessageMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageMessageID:
					goto handle_MessageID

				case ffjtMessageFrom:
					goto handle_From

				case ffjtMessageSenderChat:
					goto handle_SenderChat

				case ffjtMessageDate:
					goto handle_Date

				case ffjtMessageChat:
					goto handle_Chat

				case ffjtMessageForwardFrom:
					goto handle_ForwardFrom

				case ffjtMessageForwardFromChat:
					goto handle_ForwardFromChat

				case ffjtMessageForwardFromMessageID:
					goto handle_ForwardFromMessageID

				case ffjtMessageForwardSignature:
					goto handle_ForwardSignature

				case ffjtMessageForwardSenderName:
					goto handle_ForwardSenderName

				case ffjtMessageForwardDate:
					goto handle_ForwardDate

				case ffjtMessageIsAutomaticForward:
					goto handle_IsAutomaticForward

				case ffjtMessageReplyToMessage:
					goto handle_ReplyToMessage

				case ffjtMessageViaBot:
					goto handle_ViaBot

				case ffjtMessageEditDate:
					goto handle_EditDate

				case ffjtMessageHasProtectedContent:
					goto handle_HasProtectedContent

				case ffjtMessageMediaGroupID:
					goto handle_MediaGroupID

				case ffjtMessageAuthorSignature:
					goto handle_AuthorSignature

				case ffjtMessageText:
					goto handle_Text

				case ffjtMessageEntities:
					goto handle_Entities

				case ffjtMessageAnimation:
					goto handle_Animation

				case ffjtMessageAudio:
					goto handle_Audio

				case ffjtMessageDocument:
					goto handle_Document

				case ffjtMessagePhoto:
					goto handle_Photo

				case ffjtMessageSticker:
					goto handle_Sticker

				case ffjtMessageVideo:
					goto handle_Video

				case ffjtMessageVideoNote:
					goto handle_VideoNote

				case ffjtMessageVoice:
					goto handle_Voice

				case ffjtMessageCaption:
					goto handle_Caption

				case ffjtMessageCaptionEntities:
					goto handle_CaptionEntities

				case ffjtMessageContact:
					goto handle_Contact

				case ffjtMessageDice:
					goto handle_Dice

				case ffjtMessageGame:
					goto handle_Game

				case ffjtMessagePoll:
					goto handle_Poll

				case ffjtMessageVenue:
					goto handle_Venue

				case ffjtMessageLocation:
					goto handle_Location

				case ffjtMessageNewChatMembers:
					goto handle_NewChatMembers

				case ffjtMessageLeftChatMember:
					goto handle_LeftChatMember

				case ffjtMessageNewChatTitle:
					goto handle_NewChatTitle

				case ffjtMessageNewChatPhoto:
					goto handle_NewChatPhoto

				case ffjtMessageDeleteChatPhoto:
					goto handle_DeleteChatPhoto

				case ffjtMessageGroupChatCreated:
					goto handle_GroupChatCreated

				case ffjtMessageSupergroupChatCreated:
					goto handle_SupergroupChatCreated

				case ffjtMessageChannelChatCreated:
					goto handle_ChannelChatCreated

				case ffjtMessageMessageAutoDeleteTimerChanged:
					goto handle_MessageAutoDeleteTimerChanged

				case ffjtMessageMigrateToChatID:
					goto handle_MigrateToChatID

				case ffjtMessageMigrateFromChatID:
					goto handle_MigrateFromChatID

				case ffjtMessagePinnedMessage:
					goto handle_PinnedMessage

				case ffjtMessageInvoice:
					goto handle_Invoice

				case ffjtMessageSuccessfulPayment:
					goto handle_SuccessfulPayment

				case ffjtMessageConnectedWebsite:
					goto handle_ConnectedWebsite

				case ffjtMessagePassportData:
					goto handle_PassportData

				case ffjtMessageProximityAlertTriggered:
					goto handle_ProximityAlertTriggered

				case ffjtMessageVideoChatScheduled:
					goto handle_VideoChatScheduled

				case ffjtMessageVideoChatStarted:
					goto handle_VideoChatStarted

				case ffjtMessageVideoChatEnded:
					goto handle_VideoChatEnded

				case ffjtMessageVideoChatParticipantsInvited:
					goto handle_VideoChatParticipantsInvited

				case ffjtMessageWebAppData:
					goto handle_WebAppData

				case ffjtMessageReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtMessagenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MessageID:

	/* handler: j.MessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SenderChat:

	/* handler: j.SenderChat type=model.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.SenderChat = nil

		} else {

			if j.SenderChat == nil {
				j.SenderChat = new(Chat)
			}

			err = j.SenderChat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: j.Date type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Date = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chat:

	/* handler: j.Chat type=model.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Chat = nil

		} else {

			if j.Chat == nil {
				j.Chat = new(Chat)
			}

			err = j.Chat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFrom:

	/* handler: j.ForwardFrom type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ForwardFrom = nil

		} else {

			if j.ForwardFrom == nil {
				j.ForwardFrom = new(User)
			}

			err = j.ForwardFrom.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFromChat:

	/* handler: j.ForwardFromChat type=model.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ForwardFromChat = nil

		} else {

			if j.ForwardFromChat == nil {
				j.ForwardFromChat = new(Chat)
			}

			err = j.ForwardFromChat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFromMessageID:

	/* handler: j.ForwardFromMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ForwardFromMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardSignature:

	/* handler: j.ForwardSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ForwardSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardSenderName:

	/* handler: j.ForwardSenderName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ForwardSenderName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardDate:

	/* handler: j.ForwardDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ForwardDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsAutomaticForward:

	/* handler: j.IsAutomaticForward type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsAutomaticForward = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsAutomaticForward = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessage:

	/* handler: j.ReplyToMessage type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyToMessage = nil

		} else {

			if j.ReplyToMessage == nil {
				j.ReplyToMessage = new(Message)
			}

			err = j.ReplyToMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ViaBot:

	/* handler: j.ViaBot type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ViaBot = nil

		} else {

			if j.ViaBot == nil {
				j.ViaBot = new(User)
			}

			err = j.ViaBot.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditDate:

	/* handler: j.EditDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.EditDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HasProtectedContent:

	/* handler: j.HasProtectedContent type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HasProtectedContent = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HasProtectedContent = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MediaGroupID:

	/* handler: j.MediaGroupID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MediaGroupID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AuthorSignature:

	/* handler: j.AuthorSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AuthorSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entities:

	/* handler: j.Entities type=[]*model.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Entities = nil
		} else {

			j.Entities = []*MessageEntity{}

			wantVal := true

			for {

				var tmpJEntities *MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEntities type=*model.MessageEntity kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJEntities = nil

					} else {

						if tmpJEntities == nil {
							tmpJEntities = new(MessageEntity)
						}

						err = tmpJEntities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Entities = append(j.Entities, tmpJEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Animation:

	/* handler: j.Animation type=model.Animation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Animation = nil

		} else {

			if j.Animation == nil {
				j.Animation = new(Animation)
			}

			err = j.Animation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Audio:

	/* handler: j.Audio type=model.Audio kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Audio = nil

		} else {

			if j.Audio == nil {
				j.Audio = new(Audio)
			}

			err = j.Audio.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Document:

	/* handler: j.Document type=model.Document kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Document = nil

		} else {

			if j.Document == nil {
				j.Document = new(Document)
			}

			err = j.Document.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=[]*model.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Photo = nil
		} else {

			j.Photo = []*PhotoSize{}

			wantVal := true

			for {

				var tmpJPhoto *PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPhoto type=*model.PhotoSize kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJPhoto = nil

					} else {

						if tmpJPhoto == nil {
							tmpJPhoto = new(PhotoSize)
						}

						err = tmpJPhoto.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Photo = append(j.Photo, tmpJPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sticker:

	/* handler: j.Sticker type=model.Sticker kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Sticker = nil

		} else {

			if j.Sticker == nil {
				j.Sticker = new(Sticker)
			}

			err = j.Sticker.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Video:

	/* handler: j.Video type=model.Video kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Video = nil

		} else {

			if j.Video == nil {
				j.Video = new(Video)
			}

			err = j.Video.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoNote:

	/* handler: j.VideoNote type=model.VideoNote kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.VideoNote = nil

		} else {

			if j.VideoNote == nil {
				j.VideoNote = new(VideoNote)
			}

			err = j.VideoNote.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Voice:

	/* handler: j.Voice type=model.Voice kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Voice = nil

		} else {

			if j.Voice == nil {
				j.Voice = new(Voice)
			}

			err = j.Voice.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CaptionEntities:

	/* handler: j.CaptionEntities type=[]*model.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.CaptionEntities = nil
		} else {

			j.CaptionEntities = []*MessageEntity{}

			wantVal := true

			for {

				var tmpJCaptionEntities *MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCaptionEntities type=*model.MessageEntity kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJCaptionEntities = nil

					} else {

						if tmpJCaptionEntities == nil {
							tmpJCaptionEntities = new(MessageEntity)
						}

						err = tmpJCaptionEntities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.CaptionEntities = append(j.CaptionEntities, tmpJCaptionEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Contact:

	/* handler: j.Contact type=model.Contact kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Contact = nil

		} else {

			if j.Contact == nil {
				j.Contact = new(Contact)
			}

			err = j.Contact.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dice:

	/* handler: j.Dice type=model.Dice kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Dice = nil

		} else {

			if j.Dice == nil {
				j.Dice = new(Dice)
			}

			err = j.Dice.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Game:

	/* handler: j.Game type=model.Game kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Game = nil

		} else {

			if j.Game == nil {
				j.Game = new(Game)
			}

			err = j.Game.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Poll:

	/* handler: j.Poll type=model.Poll kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Poll = nil

		} else {

			if j.Poll == nil {
				j.Poll = new(Poll)
			}

			err = j.Poll.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Venue:

	/* handler: j.Venue type=model.Venue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Venue = nil

		} else {

			if j.Venue == nil {
				j.Venue = new(Venue)
			}

			err = j.Venue.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=model.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMembers:

	/* handler: j.NewChatMembers type=[]*model.User kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NewChatMembers = nil
		} else {

			j.NewChatMembers = []*User{}

			wantVal := true

			for {

				var tmpJNewChatMembers *User

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNewChatMembers type=*model.User kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJNewChatMembers = nil

					} else {

						if tmpJNewChatMembers == nil {
							tmpJNewChatMembers = new(User)
						}

						err = tmpJNewChatMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.NewChatMembers = append(j.NewChatMembers, tmpJNewChatMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LeftChatMember:

	/* handler: j.LeftChatMember type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.LeftChatMember = nil

		} else {

			if j.LeftChatMember == nil {
				j.LeftChatMember = new(User)
			}

			err = j.LeftChatMember.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatTitle:

	/* handler: j.NewChatTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NewChatTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatPhoto:

	/* handler: j.NewChatPhoto type=[]*model.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NewChatPhoto = nil
		} else {

			j.NewChatPhoto = []*PhotoSize{}

			wantVal := true

			for {

				var tmpJNewChatPhoto *PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNewChatPhoto type=*model.PhotoSize kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJNewChatPhoto = nil

					} else {

						if tmpJNewChatPhoto == nil {
							tmpJNewChatPhoto = new(PhotoSize)
						}

						err = tmpJNewChatPhoto.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.NewChatPhoto = append(j.NewChatPhoto, tmpJNewChatPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeleteChatPhoto:

	/* handler: j.DeleteChatPhoto type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DeleteChatPhoto = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DeleteChatPhoto = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GroupChatCreated:

	/* handler: j.GroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.GroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.GroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SupergroupChatCreated:

	/* handler: j.SupergroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SupergroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SupergroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelChatCreated:

	/* handler: j.ChannelChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ChannelChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ChannelChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageAutoDeleteTimerChanged:

	/* handler: j.MessageAutoDeleteTimerChanged type=model.MessageAutoDeleteTimerChanged kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.MessageAutoDeleteTimerChanged = nil

		} else {

			if j.MessageAutoDeleteTimerChanged == nil {
				j.MessageAutoDeleteTimerChanged = new(MessageAutoDeleteTimerChanged)
			}

			err = j.MessageAutoDeleteTimerChanged.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateToChatID:

	/* handler: j.MigrateToChatID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MigrateToChatID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateFromChatID:

	/* handler: j.MigrateFromChatID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MigrateFromChatID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PinnedMessage:

	/* handler: j.PinnedMessage type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PinnedMessage = nil

		} else {

			if j.PinnedMessage == nil {
				j.PinnedMessage = new(Message)
			}

			err = j.PinnedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Invoice:

	/* handler: j.Invoice type=model.Invoice kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Invoice = nil

		} else {

			if j.Invoice == nil {
				j.Invoice = new(Invoice)
			}

			err = j.Invoice.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuccessfulPayment:

	/* handler: j.SuccessfulPayment type=model.SuccessfulPayment kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.SuccessfulPayment = nil

		} else {

			if j.SuccessfulPayment == nil {
				j.SuccessfulPayment = new(SuccessfulPayment)
			}

			err = j.SuccessfulPayment.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConnectedWebsite:

	/* handler: j.ConnectedWebsite type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ConnectedWebsite = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PassportData:

	/* handler: j.PassportData type=model.PassportData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PassportData = nil

		} else {

			if j.PassportData == nil {
				j.PassportData = new(PassportData)
			}

			err = j.PassportData.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProximityAlertTriggered:

	/* handler: j.ProximityAlertTriggered type=model.ProximityAlertTriggered kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ProximityAlertTriggered = nil

		} else {

			if j.ProximityAlertTriggered == nil {
				j.ProximityAlertTriggered = new(ProximityAlertTriggered)
			}

			err = j.ProximityAlertTriggered.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoChatScheduled:

	/* handler: j.VideoChatScheduled type=model.VideoChatScheduled kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.VideoChatScheduled = nil

		} else {

			if j.VideoChatScheduled == nil {
				j.VideoChatScheduled = new(VideoChatScheduled)
			}

			err = j.VideoChatScheduled.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoChatStarted:

	/* handler: j.VideoChatStarted type=model.VideoChatStarted kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.VideoChatStarted = nil

		} else {

			if j.VideoChatStarted == nil {
				j.VideoChatStarted = new(VideoChatStarted)
			}

			err = j.VideoChatStarted.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoChatEnded:

	/* handler: j.VideoChatEnded type=model.VideoChatEnded kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.VideoChatEnded = nil

		} else {

			if j.VideoChatEnded == nil {
				j.VideoChatEnded = new(VideoChatEnded)
			}

			err = j.VideoChatEnded.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VideoChatParticipantsInvited:

	/* handler: j.VideoChatParticipantsInvited type=model.VideoChatParticipantsInvited kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.VideoChatParticipantsInvited = nil

		} else {

			if j.VideoChatParticipantsInvited == nil {
				j.VideoChatParticipantsInvited = new(VideoChatParticipantsInvited)
			}

			err = j.VideoChatParticipantsInvited.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WebAppData:

	/* handler: j.WebAppData type=model.WebAppData kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.WebAppData = nil

		} else {

			if j.WebAppData == nil {
				j.WebAppData = new(WebAppData)
			}

			err = j.WebAppData.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=model.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyMarkup = nil

		} else {

			if j.ReplyMarkup == nil {
				j.ReplyMarkup = new(InlineKeyboardMarkup)
			}

			err = j.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageAutoDeleteTimerChanged) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageAutoDeleteTimerChanged) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"message_auto_delete_time":`)
	fflib.FormatBits2(buf, uint64(j.MessageAutoDeleteTime), 10, j.MessageAutoDeleteTime < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageAutoDeleteTimerChangedbase = iota
	ffjtMessageAutoDeleteTimerChangednosuchkey

	ffjtMessageAutoDeleteTimerChangedMessageAutoDeleteTime
)

var ffjKeyMessageAutoDeleteTimerChangedMessageAutoDeleteTime = []byte("message_auto_delete_time")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageAutoDeleteTimerChanged) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageAutoDeleteTimerChanged) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageAutoDeleteTimerChangedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageAutoDeleteTimerChangednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffjKeyMessageAutoDeleteTimerChangedMessageAutoDeleteTime, kn) {
						currentKey = ffjtMessageAutoDeleteTimerChangedMessageAutoDeleteTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessageAutoDeleteTimerChangedMessageAutoDeleteTime, kn) {
					currentKey = ffjtMessageAutoDeleteTimerChangedMessageAutoDeleteTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageAutoDeleteTimerChangednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageAutoDeleteTimerChangedMessageAutoDeleteTime:
					goto handle_MessageAutoDeleteTime

				case ffjtMessageAutoDeleteTimerChangednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MessageAutoDeleteTime:

	/* handler: j.MessageAutoDeleteTime type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MessageAutoDeleteTime = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageEntity) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageEntity) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"offset":`)
	fflib.FormatBits2(buf, uint64(j.Offset), 10, j.Offset < 0)
	buf.WriteString(`,"length":`)
	fflib.FormatBits2(buf, uint64(j.Length), 10, j.Length < 0)
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	if j.User != nil {
		if true {
			buf.WriteString(`"user":`)

			{

				err = j.User.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Language) != 0 {
		buf.WriteString(`"language":`)
		fflib.WriteJsonString(buf, string(j.Language))
		buf.WriteByte(',')
	}
	if len(j.CustomEmojiID) != 0 {
		buf.WriteString(`"custom_emoji_id":`)
		fflib.WriteJsonString(buf, string(j.CustomEmojiID))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageEntitybase = iota
	ffjtMessageEntitynosuchkey

	ffjtMessageEntityType

	ffjtMessageEntityOffset

	ffjtMessageEntityLength

	ffjtMessageEntityURL

	ffjtMessageEntityUser

	ffjtMessageEntityLanguage

	ffjtMessageEntityCustomEmojiID
)

var ffjKeyMessageEntityType = []byte("type")

var ffjKeyMessageEntityOffset = []byte("offset")

var ffjKeyMessageEntityLength = []byte("length")

var ffjKeyMessageEntityURL = []byte("url")

var ffjKeyMessageEntityUser = []byte("user")

var ffjKeyMessageEntityLanguage = []byte("language")

var ffjKeyMessageEntityCustomEmojiID = []byte("custom_emoji_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageEntity) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageEntity) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageEntitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageEntitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyMessageEntityCustomEmojiID, kn) {
						currentKey = ffjtMessageEntityCustomEmojiID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyMessageEntityLength, kn) {
						currentKey = ffjtMessageEntityLength
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageEntityLanguage, kn) {
						currentKey = ffjtMessageEntityLanguage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyMessageEntityOffset, kn) {
						currentKey = ffjtMessageEntityOffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageEntityType, kn) {
						currentKey = ffjtMessageEntityType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyMessageEntityURL, kn) {
						currentKey = ffjtMessageEntityURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageEntityUser, kn) {
						currentKey = ffjtMessageEntityUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessageEntityCustomEmojiID, kn) {
					currentKey = ffjtMessageEntityCustomEmojiID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityLanguage, kn) {
					currentKey = ffjtMessageEntityLanguage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageEntityUser, kn) {
					currentKey = ffjtMessageEntityUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityURL, kn) {
					currentKey = ffjtMessageEntityURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityLength, kn) {
					currentKey = ffjtMessageEntityLength
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageEntityOffset, kn) {
					currentKey = ffjtMessageEntityOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityType, kn) {
					currentKey = ffjtMessageEntityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageEntitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageEntityType:
					goto handle_Type

				case ffjtMessageEntityOffset:
					goto handle_Offset

				case ffjtMessageEntityLength:
					goto handle_Length

				case ffjtMessageEntityURL:
					goto handle_URL

				case ffjtMessageEntityUser:
					goto handle_User

				case ffjtMessageEntityLanguage:
					goto handle_Language

				case ffjtMessageEntityCustomEmojiID:
					goto handle_CustomEmojiID

				case ffjtMessageEntitynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: j.Offset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Offset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Length:

	/* handler: j.Length type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Length = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Language:

	/* handler: j.Language type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Language = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomEmojiID:

	/* handler: j.CustomEmojiID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CustomEmojiID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *OrderInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *OrderInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(j.Name))
		buf.WriteByte(',')
	}
	if len(j.PhoneNumber) != 0 {
		buf.WriteString(`"phone_number":`)
		fflib.WriteJsonString(buf, string(j.PhoneNumber))
		buf.WriteByte(',')
	}
	if len(j.Email) != 0 {
		buf.WriteString(`"email":`)
		fflib.WriteJsonString(buf, string(j.Email))
		buf.WriteByte(',')
	}
	if j.ShippingAddress != nil {
		if true {
			buf.WriteString(`"shipping_address":`)

			{

				err = j.ShippingAddress.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtOrderInfobase = iota
	ffjtOrderInfonosuchkey

	ffjtOrderInfoName

	ffjtOrderInfoPhoneNumber

	ffjtOrderInfoEmail

	ffjtOrderInfoShippingAddress
)

var ffjKeyOrderInfoName = []byte("name")

var ffjKeyOrderInfoPhoneNumber = []byte("phone_number")

var ffjKeyOrderInfoEmail = []byte("email")

var ffjKeyOrderInfoShippingAddress = []byte("shipping_address")

// UnmarshalJSON umarshall json - template of ffjson
func (j *OrderInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *OrderInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtOrderInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtOrderInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyOrderInfoEmail, kn) {
						currentKey = ffjtOrderInfoEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyOrderInfoName, kn) {
						currentKey = ffjtOrderInfoName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyOrderInfoPhoneNumber, kn) {
						currentKey = ffjtOrderInfoPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyOrderInfoShippingAddress, kn) {
						currentKey = ffjtOrderInfoShippingAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyOrderInfoShippingAddress, kn) {
					currentKey = ffjtOrderInfoShippingAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderInfoEmail, kn) {
					currentKey = ffjtOrderInfoEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyOrderInfoPhoneNumber, kn) {
					currentKey = ffjtOrderInfoPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyOrderInfoName, kn) {
					currentKey = ffjtOrderInfoName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtOrderInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtOrderInfoName:
					goto handle_Name

				case ffjtOrderInfoPhoneNumber:
					goto handle_PhoneNumber

				case ffjtOrderInfoEmail:
					goto handle_Email

				case ffjtOrderInfoShippingAddress:
					goto handle_ShippingAddress

				case ffjtOrderInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: j.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingAddress:

	/* handler: j.ShippingAddress type=model.ShippingAddress kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ShippingAddress = nil

		} else {

			if j.ShippingAddress == nil {
				j.ShippingAddress = new(ShippingAddress)
			}

			err = j.ShippingAddress.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"data":`)
	if j.Data != nil {
		buf.WriteString(`[`)
		for i, v := range j.Data {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				if v == nil {
					buf.WriteString("null")
				} else {

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.Credentials != nil {
		buf.WriteString(`,"credentials":`)

		{

			err = j.Credentials.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"credentials":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportDatabase = iota
	ffjtPassportDatanosuchkey

	ffjtPassportDataData

	ffjtPassportDataCredentials
)

var ffjKeyPassportDataData = []byte("data")

var ffjKeyPassportDataCredentials = []byte("credentials")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyPassportDataCredentials, kn) {
						currentKey = ffjtPassportDataCredentials
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyPassportDataData, kn) {
						currentKey = ffjtPassportDataData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPassportDataCredentials, kn) {
					currentKey = ffjtPassportDataCredentials
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPassportDataData, kn) {
					currentKey = ffjtPassportDataData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportDataData:
					goto handle_Data

				case ffjtPassportDataCredentials:
					goto handle_Credentials

				case ffjtPassportDatanosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Data:

	/* handler: j.Data type=[]*model.EncryptedPassportElement kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Data = nil
		} else {

			j.Data = []*EncryptedPassportElement{}

			wantVal := true

			for {

				var tmpJData *EncryptedPassportElement

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJData type=*model.EncryptedPassportElement kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJData = nil

					} else {

						if tmpJData == nil {
							tmpJData = new(EncryptedPassportElement)
						}

						err = tmpJData.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Data = append(j.Data, tmpJData)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Credentials:

	/* handler: j.Credentials type=model.EncryptedCredentials kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Credentials = nil

		} else {

			if j.Credentials == nil {
				j.Credentials = new(EncryptedCredentials)
			}

			err = j.Credentials.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PassportFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PassportFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"file_size":`)
	fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
	buf.WriteString(`,"file_date":`)
	fflib.FormatBits2(buf, uint64(j.FileDate), 10, j.FileDate < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPassportFilebase = iota
	ffjtPassportFilenosuchkey

	ffjtPassportFileFileID

	ffjtPassportFileFileUniqueID

	ffjtPassportFileFileSize

	ffjtPassportFileFileDate
)

var ffjKeyPassportFileFileID = []byte("file_id")

var ffjKeyPassportFileFileUniqueID = []byte("file_unique_id")

var ffjKeyPassportFileFileSize = []byte("file_size")

var ffjKeyPassportFileFileDate = []byte("file_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PassportFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PassportFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPassportFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPassportFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPassportFileFileID, kn) {
						currentKey = ffjtPassportFileFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportFileFileUniqueID, kn) {
						currentKey = ffjtPassportFileFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportFileFileSize, kn) {
						currentKey = ffjtPassportFileFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPassportFileFileDate, kn) {
						currentKey = ffjtPassportFileFileDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyPassportFileFileDate, kn) {
					currentKey = ffjtPassportFileFileDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPassportFileFileSize, kn) {
					currentKey = ffjtPassportFileFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportFileFileUniqueID, kn) {
					currentKey = ffjtPassportFileFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPassportFileFileID, kn) {
					currentKey = ffjtPassportFileFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPassportFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPassportFileFileID:
					goto handle_FileID

				case ffjtPassportFileFileUniqueID:
					goto handle_FileUniqueID

				case ffjtPassportFileFileSize:
					goto handle_FileSize

				case ffjtPassportFileFileDate:
					goto handle_FileDate

				case ffjtPassportFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileDate:

	/* handler: j.FileDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PhotoSize) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PhotoSize) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPhotoSizebase = iota
	ffjtPhotoSizenosuchkey

	ffjtPhotoSizeFileID

	ffjtPhotoSizeFileUniqueID

	ffjtPhotoSizeWidth

	ffjtPhotoSizeHeight

	ffjtPhotoSizeFileSize
)

var ffjKeyPhotoSizeFileID = []byte("file_id")

var ffjKeyPhotoSizeFileUniqueID = []byte("file_unique_id")

var ffjKeyPhotoSizeWidth = []byte("width")

var ffjKeyPhotoSizeHeight = []byte("height")

var ffjKeyPhotoSizeFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PhotoSize) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PhotoSize) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPhotoSizebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPhotoSizenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyPhotoSizeFileID, kn) {
						currentKey = ffjtPhotoSizeFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPhotoSizeFileUniqueID, kn) {
						currentKey = ffjtPhotoSizeFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPhotoSizeFileSize, kn) {
						currentKey = ffjtPhotoSizeFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyPhotoSizeHeight, kn) {
						currentKey = ffjtPhotoSizeHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyPhotoSizeWidth, kn) {
						currentKey = ffjtPhotoSizeWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPhotoSizeFileSize, kn) {
					currentKey = ffjtPhotoSizeFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPhotoSizeHeight, kn) {
					currentKey = ffjtPhotoSizeHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPhotoSizeWidth, kn) {
					currentKey = ffjtPhotoSizeWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPhotoSizeFileUniqueID, kn) {
					currentKey = ffjtPhotoSizeFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPhotoSizeFileID, kn) {
					currentKey = ffjtPhotoSizeFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPhotoSizenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPhotoSizeFileID:
					goto handle_FileID

				case ffjtPhotoSizeFileUniqueID:
					goto handle_FileUniqueID

				case ffjtPhotoSizeWidth:
					goto handle_Width

				case ffjtPhotoSizeHeight:
					goto handle_Height

				case ffjtPhotoSizeFileSize:
					goto handle_FileSize

				case ffjtPhotoSizenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Poll) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Poll) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"question":`)
	fflib.WriteJsonString(buf, string(j.Question))
	buf.WriteString(`,"options":`)
	if j.Options != nil {
		buf.WriteString(`[`)
		for i, v := range j.Options {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				if v == nil {
					buf.WriteString("null")
				} else {

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"total_voter_count":`)
	fflib.FormatBits2(buf, uint64(j.TotalVoterCount), 10, j.TotalVoterCount < 0)
	if j.IsClosed {
		buf.WriteString(`,"is_closed":true`)
	} else {
		buf.WriteString(`,"is_closed":false`)
	}
	if j.IsAnonymous {
		buf.WriteString(`,"is_anonymous":true`)
	} else {
		buf.WriteString(`,"is_anonymous":false`)
	}
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	if j.AllowsMultipleAnswers {
		buf.WriteString(`,"allows_multiple_answers":true`)
	} else {
		buf.WriteString(`,"allows_multiple_answers":false`)
	}
	buf.WriteByte(',')
	if j.CorrectOptionID != 0 {
		buf.WriteString(`"correct_option_id":`)
		fflib.FormatBits2(buf, uint64(j.CorrectOptionID), 10, j.CorrectOptionID < 0)
		buf.WriteByte(',')
	}
	if len(j.Explanation) != 0 {
		buf.WriteString(`"explanation":`)
		fflib.WriteJsonString(buf, string(j.Explanation))
		buf.WriteByte(',')
	}
	if len(j.ExplanationEntities) != 0 {
		buf.WriteString(`"explanation_entities":`)
		if j.ExplanationEntities != nil {
			buf.WriteString(`[`)
			for i, v := range j.ExplanationEntities {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.OpenPeriod != 0 {
		buf.WriteString(`"open_period":`)
		fflib.FormatBits2(buf, uint64(j.OpenPeriod), 10, j.OpenPeriod < 0)
		buf.WriteByte(',')
	}
	buf.WriteString(`"close_date":`)
	fflib.FormatBits2(buf, uint64(j.CloseDate), 10, j.CloseDate < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPollbase = iota
	ffjtPollnosuchkey

	ffjtPollID

	ffjtPollQuestion

	ffjtPollOptions

	ffjtPollTotalVoterCount

	ffjtPollIsClosed

	ffjtPollIsAnonymous

	ffjtPollType

	ffjtPollAllowsMultipleAnswers

	ffjtPollCorrectOptionID

	ffjtPollExplanation

	ffjtPollExplanationEntities

	ffjtPollOpenPeriod

	ffjtPollCloseDate
)

var ffjKeyPollID = []byte("id")

var ffjKeyPollQuestion = []byte("question")

var ffjKeyPollOptions = []byte("options")

var ffjKeyPollTotalVoterCount = []byte("total_voter_count")

var ffjKeyPollIsClosed = []byte("is_closed")

var ffjKeyPollIsAnonymous = []byte("is_anonymous")

var ffjKeyPollType = []byte("type")

var ffjKeyPollAllowsMultipleAnswers = []byte("allows_multiple_answers")

var ffjKeyPollCorrectOptionID = []byte("correct_option_id")

var ffjKeyPollExplanation = []byte("explanation")

var ffjKeyPollExplanationEntities = []byte("explanation_entities")

var ffjKeyPollOpenPeriod = []byte("open_period")

var ffjKeyPollCloseDate = []byte("close_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Poll) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Poll) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPollbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPollnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyPollAllowsMultipleAnswers, kn) {
						currentKey = ffjtPollAllowsMultipleAnswers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyPollCorrectOptionID, kn) {
						currentKey = ffjtPollCorrectOptionID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPollCloseDate, kn) {
						currentKey = ffjtPollCloseDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyPollExplanation, kn) {
						currentKey = ffjtPollExplanation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPollExplanationEntities, kn) {
						currentKey = ffjtPollExplanationEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyPollID, kn) {
						currentKey = ffjtPollID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPollIsClosed, kn) {
						currentKey = ffjtPollIsClosed
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPollIsAnonymous, kn) {
						currentKey = ffjtPollIsAnonymous
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyPollOptions, kn) {
						currentKey = ffjtPollOptions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPollOpenPeriod, kn) {
						currentKey = ffjtPollOpenPeriod
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyPollQuestion, kn) {
						currentKey = ffjtPollQuestion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPollTotalVoterCount, kn) {
						currentKey = ffjtPollTotalVoterCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPollType, kn) {
						currentKey = ffjtPollType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPollCloseDate, kn) {
					currentKey = ffjtPollCloseDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPollOpenPeriod, kn) {
					currentKey = ffjtPollOpenPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollExplanationEntities, kn) {
					currentKey = ffjtPollExplanationEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPollExplanation, kn) {
					currentKey = ffjtPollExplanation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPollCorrectOptionID, kn) {
					currentKey = ffjtPollCorrectOptionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollAllowsMultipleAnswers, kn) {
					currentKey = ffjtPollAllowsMultipleAnswers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPollType, kn) {
					currentKey = ffjtPollType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollIsAnonymous, kn) {
					currentKey = ffjtPollIsAnonymous
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollIsClosed, kn) {
					currentKey = ffjtPollIsClosed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPollTotalVoterCount, kn) {
					currentKey = ffjtPollTotalVoterCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollOptions, kn) {
					currentKey = ffjtPollOptions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollQuestion, kn) {
					currentKey = ffjtPollQuestion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPollID, kn) {
					currentKey = ffjtPollID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPollnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPollID:
					goto handle_ID

				case ffjtPollQuestion:
					goto handle_Question

				case ffjtPollOptions:
					goto handle_Options

				case ffjtPollTotalVoterCount:
					goto handle_TotalVoterCount

				case ffjtPollIsClosed:
					goto handle_IsClosed

				case ffjtPollIsAnonymous:
					goto handle_IsAnonymous

				case ffjtPollType:
					goto handle_Type

				case ffjtPollAllowsMultipleAnswers:
					goto handle_AllowsMultipleAnswers

				case ffjtPollCorrectOptionID:
					goto handle_CorrectOptionID

				case ffjtPollExplanation:
					goto handle_Explanation

				case ffjtPollExplanationEntities:
					goto handle_ExplanationEntities

				case ffjtPollOpenPeriod:
					goto handle_OpenPeriod

				case ffjtPollCloseDate:
					goto handle_CloseDate

				case ffjtPollnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Question:

	/* handler: j.Question type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Question = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Options:

	/* handler: j.Options type=[]*model.PollOption kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Options = nil
		} else {

			j.Options = []*PollOption{}

			wantVal := true

			for {

				var tmpJOptions *PollOption

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOptions type=*model.PollOption kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJOptions = nil

					} else {

						if tmpJOptions == nil {
							tmpJOptions = new(PollOption)
						}

						err = tmpJOptions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Options = append(j.Options, tmpJOptions)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalVoterCount:

	/* handler: j.TotalVoterCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalVoterCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsClosed:

	/* handler: j.IsClosed type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsClosed = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsClosed = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsAnonymous:

	/* handler: j.IsAnonymous type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsAnonymous = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsAnonymous = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllowsMultipleAnswers:

	/* handler: j.AllowsMultipleAnswers type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllowsMultipleAnswers = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllowsMultipleAnswers = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CorrectOptionID:

	/* handler: j.CorrectOptionID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CorrectOptionID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Explanation:

	/* handler: j.Explanation type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Explanation = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExplanationEntities:

	/* handler: j.ExplanationEntities type=[]*model.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ExplanationEntities = nil
		} else {

			j.ExplanationEntities = []*MessageEntity{}

			wantVal := true

			for {

				var tmpJExplanationEntities *MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJExplanationEntities type=*model.MessageEntity kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJExplanationEntities = nil

					} else {

						if tmpJExplanationEntities == nil {
							tmpJExplanationEntities = new(MessageEntity)
						}

						err = tmpJExplanationEntities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ExplanationEntities = append(j.ExplanationEntities, tmpJExplanationEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OpenPeriod:

	/* handler: j.OpenPeriod type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.OpenPeriod = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CloseDate:

	/* handler: j.CloseDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CloseDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PollAnswer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PollAnswer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"poll_id":`)
	fflib.WriteJsonString(buf, string(j.PollID))
	if j.User != nil {
		buf.WriteString(`,"user":`)

		{

			err = j.User.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"user":null`)
	}
	buf.WriteString(`,"option_ids":`)
	if j.OptionIDs != nil {
		buf.WriteString(`[`)
		for i, v := range j.OptionIDs {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.FormatBits2(buf, uint64(v), 10, v < 0)
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPollAnswerbase = iota
	ffjtPollAnswernosuchkey

	ffjtPollAnswerPollID

	ffjtPollAnswerUser

	ffjtPollAnswerOptionIDs
)

var ffjKeyPollAnswerPollID = []byte("poll_id")

var ffjKeyPollAnswerUser = []byte("user")

var ffjKeyPollAnswerOptionIDs = []byte("option_ids")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PollAnswer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PollAnswer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPollAnswerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPollAnswernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'o':

					if bytes.Equal(ffjKeyPollAnswerOptionIDs, kn) {
						currentKey = ffjtPollAnswerOptionIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyPollAnswerPollID, kn) {
						currentKey = ffjtPollAnswerPollID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyPollAnswerUser, kn) {
						currentKey = ffjtPollAnswerUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyPollAnswerOptionIDs, kn) {
					currentKey = ffjtPollAnswerOptionIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPollAnswerUser, kn) {
					currentKey = ffjtPollAnswerUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPollAnswerPollID, kn) {
					currentKey = ffjtPollAnswerPollID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPollAnswernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPollAnswerPollID:
					goto handle_PollID

				case ffjtPollAnswerUser:
					goto handle_User

				case ffjtPollAnswerOptionIDs:
					goto handle_OptionIDs

				case ffjtPollAnswernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PollID:

	/* handler: j.PollID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PollID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.User = nil

		} else {

			if j.User == nil {
				j.User = new(User)
			}

			err = j.User.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OptionIDs:

	/* handler: j.OptionIDs type=[]int kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.OptionIDs = nil
		} else {

			j.OptionIDs = []int{}

			wantVal := true

			for {

				var tmpJOptionIDs int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJOptionIDs type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJOptionIDs = int(tval)

					}
				}

				j.OptionIDs = append(j.OptionIDs, tmpJOptionIDs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PollOption) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PollOption) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteString(`,"voter_count":`)
	fflib.FormatBits2(buf, uint64(j.VoterCount), 10, j.VoterCount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPollOptionbase = iota
	ffjtPollOptionnosuchkey

	ffjtPollOptionText

	ffjtPollOptionVoterCount
)

var ffjKeyPollOptionText = []byte("text")

var ffjKeyPollOptionVoterCount = []byte("voter_count")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PollOption) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PollOption) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPollOptionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPollOptionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffjKeyPollOptionText, kn) {
						currentKey = ffjtPollOptionText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyPollOptionVoterCount, kn) {
						currentKey = ffjtPollOptionVoterCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyPollOptionVoterCount, kn) {
					currentKey = ffjtPollOptionVoterCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPollOptionText, kn) {
					currentKey = ffjtPollOptionText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPollOptionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPollOptionText:
					goto handle_Text

				case ffjtPollOptionVoterCount:
					goto handle_VoterCount

				case ffjtPollOptionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VoterCount:

	/* handler: j.VoterCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.VoterCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *PreCheckoutQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *PreCheckoutQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteString(`,"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"total_amount":`)
	fflib.FormatBits2(buf, uint64(j.TotalAmount), 10, j.TotalAmount < 0)
	buf.WriteString(`,"invoice_payload":`)
	fflib.WriteJsonString(buf, string(j.InvoicePayload))
	buf.WriteByte(',')
	if len(j.ShippingOptionID) != 0 {
		buf.WriteString(`"shipping_option_id":`)
		fflib.WriteJsonString(buf, string(j.ShippingOptionID))
		buf.WriteByte(',')
	}
	if j.OrderInfo != nil {
		if true {
			buf.WriteString(`"order_info":`)

			{

				err = j.OrderInfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtPreCheckoutQuerybase = iota
	ffjtPreCheckoutQuerynosuchkey

	ffjtPreCheckoutQueryID

	ffjtPreCheckoutQueryFrom

	ffjtPreCheckoutQueryCurrency

	ffjtPreCheckoutQueryTotalAmount

	ffjtPreCheckoutQueryInvoicePayload

	ffjtPreCheckoutQueryShippingOptionID

	ffjtPreCheckoutQueryOrderInfo
)

var ffjKeyPreCheckoutQueryID = []byte("id")

var ffjKeyPreCheckoutQueryFrom = []byte("from")

var ffjKeyPreCheckoutQueryCurrency = []byte("currency")

var ffjKeyPreCheckoutQueryTotalAmount = []byte("total_amount")

var ffjKeyPreCheckoutQueryInvoicePayload = []byte("invoice_payload")

var ffjKeyPreCheckoutQueryShippingOptionID = []byte("shipping_option_id")

var ffjKeyPreCheckoutQueryOrderInfo = []byte("order_info")

// UnmarshalJSON umarshall json - template of ffjson
func (j *PreCheckoutQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *PreCheckoutQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtPreCheckoutQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtPreCheckoutQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyPreCheckoutQueryCurrency, kn) {
						currentKey = ffjtPreCheckoutQueryCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyPreCheckoutQueryFrom, kn) {
						currentKey = ffjtPreCheckoutQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyPreCheckoutQueryID, kn) {
						currentKey = ffjtPreCheckoutQueryID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyPreCheckoutQueryInvoicePayload, kn) {
						currentKey = ffjtPreCheckoutQueryInvoicePayload
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyPreCheckoutQueryOrderInfo, kn) {
						currentKey = ffjtPreCheckoutQueryOrderInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyPreCheckoutQueryShippingOptionID, kn) {
						currentKey = ffjtPreCheckoutQueryShippingOptionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyPreCheckoutQueryTotalAmount, kn) {
						currentKey = ffjtPreCheckoutQueryTotalAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyPreCheckoutQueryOrderInfo, kn) {
					currentKey = ffjtPreCheckoutQueryOrderInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyPreCheckoutQueryShippingOptionID, kn) {
					currentKey = ffjtPreCheckoutQueryShippingOptionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPreCheckoutQueryInvoicePayload, kn) {
					currentKey = ffjtPreCheckoutQueryInvoicePayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyPreCheckoutQueryTotalAmount, kn) {
					currentKey = ffjtPreCheckoutQueryTotalAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPreCheckoutQueryCurrency, kn) {
					currentKey = ffjtPreCheckoutQueryCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPreCheckoutQueryFrom, kn) {
					currentKey = ffjtPreCheckoutQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyPreCheckoutQueryID, kn) {
					currentKey = ffjtPreCheckoutQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtPreCheckoutQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtPreCheckoutQueryID:
					goto handle_ID

				case ffjtPreCheckoutQueryFrom:
					goto handle_From

				case ffjtPreCheckoutQueryCurrency:
					goto handle_Currency

				case ffjtPreCheckoutQueryTotalAmount:
					goto handle_TotalAmount

				case ffjtPreCheckoutQueryInvoicePayload:
					goto handle_InvoicePayload

				case ffjtPreCheckoutQueryShippingOptionID:
					goto handle_ShippingOptionID

				case ffjtPreCheckoutQueryOrderInfo:
					goto handle_OrderInfo

				case ffjtPreCheckoutQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAmount:

	/* handler: j.TotalAmount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalAmount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvoicePayload:

	/* handler: j.InvoicePayload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InvoicePayload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingOptionID:

	/* handler: j.ShippingOptionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShippingOptionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrderInfo:

	/* handler: j.OrderInfo type=model.OrderInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.OrderInfo = nil

		} else {

			if j.OrderInfo == nil {
				j.OrderInfo = new(OrderInfo)
			}

			err = j.OrderInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ProximityAlertTriggered) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ProximityAlertTriggered) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Traveler != nil {
		buf.WriteString(`{"traveler":`)

		{

			err = j.Traveler.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{"traveler":null`)
	}
	if j.Watcher != nil {
		buf.WriteString(`,"watcher":`)

		{

			err = j.Watcher.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"watcher":null`)
	}
	buf.WriteString(`,"distance":`)
	fflib.FormatBits2(buf, uint64(j.Distance), 10, j.Distance < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtProximityAlertTriggeredbase = iota
	ffjtProximityAlertTriggerednosuchkey

	ffjtProximityAlertTriggeredTraveler

	ffjtProximityAlertTriggeredWatcher

	ffjtProximityAlertTriggeredDistance
)

var ffjKeyProximityAlertTriggeredTraveler = []byte("traveler")

var ffjKeyProximityAlertTriggeredWatcher = []byte("watcher")

var ffjKeyProximityAlertTriggeredDistance = []byte("distance")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ProximityAlertTriggered) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ProximityAlertTriggered) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtProximityAlertTriggeredbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtProximityAlertTriggerednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyProximityAlertTriggeredDistance, kn) {
						currentKey = ffjtProximityAlertTriggeredDistance
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyProximityAlertTriggeredTraveler, kn) {
						currentKey = ffjtProximityAlertTriggeredTraveler
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyProximityAlertTriggeredWatcher, kn) {
						currentKey = ffjtProximityAlertTriggeredWatcher
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyProximityAlertTriggeredDistance, kn) {
					currentKey = ffjtProximityAlertTriggeredDistance
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyProximityAlertTriggeredWatcher, kn) {
					currentKey = ffjtProximityAlertTriggeredWatcher
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyProximityAlertTriggeredTraveler, kn) {
					currentKey = ffjtProximityAlertTriggeredTraveler
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtProximityAlertTriggerednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtProximityAlertTriggeredTraveler:
					goto handle_Traveler

				case ffjtProximityAlertTriggeredWatcher:
					goto handle_Watcher

				case ffjtProximityAlertTriggeredDistance:
					goto handle_Distance

				case ffjtProximityAlertTriggerednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Traveler:

	/* handler: j.Traveler type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Traveler = nil

		} else {

			if j.Traveler == nil {
				j.Traveler = new(User)
			}

			err = j.Traveler.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Watcher:

	/* handler: j.Watcher type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Watcher = nil

		} else {

			if j.Watcher == nil {
				j.Watcher = new(User)
			}

			err = j.Watcher.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Distance:

	/* handler: j.Distance type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Distance = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ResponseMessage) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ResponseMessage) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.OK {
		buf.WriteString(`{"ok":true`)
	} else {
		buf.WriteString(`{"ok":false`)
	}
	if j.Result != nil {
		buf.WriteString(`,"result":`)

		{

			err = j.Result.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"result":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtResponseMessagebase = iota
	ffjtResponseMessagenosuchkey

	ffjtResponseMessageOK

	ffjtResponseMessageResult
)

var ffjKeyResponseMessageOK = []byte("ok")

var ffjKeyResponseMessageResult = []byte("result")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ResponseMessage) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ResponseMessage) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResponseMessagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResponseMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'o':

					if bytes.Equal(ffjKeyResponseMessageOK, kn) {
						currentKey = ffjtResponseMessageOK
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyResponseMessageResult, kn) {
						currentKey = ffjtResponseMessageResult
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyResponseMessageResult, kn) {
					currentKey = ffjtResponseMessageResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResponseMessageOK, kn) {
					currentKey = ffjtResponseMessageOK
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtResponseMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResponseMessageOK:
					goto handle_OK

				case ffjtResponseMessageResult:
					goto handle_Result

				case ffjtResponseMessagenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_OK:

	/* handler: j.OK type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.OK = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.OK = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Result:

	/* handler: j.Result type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Result = nil

		} else {

			if j.Result == nil {
				j.Result = new(Message)
			}

			err = j.Result.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ResponseUpdate) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ResponseUpdate) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.OK {
		buf.WriteString(`{"ok":true`)
	} else {
		buf.WriteString(`{"ok":false`)
	}
	buf.WriteString(`,"result":`)
	if j.Result != nil {
		buf.WriteString(`[`)
		for i, v := range j.Result {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				if v == nil {
					buf.WriteString("null")
				} else {

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtResponseUpdatebase = iota
	ffjtResponseUpdatenosuchkey

	ffjtResponseUpdateOK

	ffjtResponseUpdateResult
)

var ffjKeyResponseUpdateOK = []byte("ok")

var ffjKeyResponseUpdateResult = []byte("result")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ResponseUpdate) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ResponseUpdate) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResponseUpdatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResponseUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'o':

					if bytes.Equal(ffjKeyResponseUpdateOK, kn) {
						currentKey = ffjtResponseUpdateOK
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyResponseUpdateResult, kn) {
						currentKey = ffjtResponseUpdateResult
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyResponseUpdateResult, kn) {
					currentKey = ffjtResponseUpdateResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResponseUpdateOK, kn) {
					currentKey = ffjtResponseUpdateOK
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtResponseUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResponseUpdateOK:
					goto handle_OK

				case ffjtResponseUpdateResult:
					goto handle_Result

				case ffjtResponseUpdatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_OK:

	/* handler: j.OK type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.OK = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.OK = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Result:

	/* handler: j.Result type=[]*model.Update kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Result = nil
		} else {

			j.Result = []*Update{}

			wantVal := true

			for {

				var tmpJResult *Update

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJResult type=*model.Update kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJResult = nil

					} else {

						if tmpJResult == nil {
							tmpJResult = new(Update)
						}

						err = tmpJResult.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Result = append(j.Result, tmpJResult)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ResponseUser) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ResponseUser) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.OK {
		buf.WriteString(`{"ok":true`)
	} else {
		buf.WriteString(`{"ok":false`)
	}
	if j.Result != nil {
		buf.WriteString(`,"result":`)

		{

			err = j.Result.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"result":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtResponseUserbase = iota
	ffjtResponseUsernosuchkey

	ffjtResponseUserOK

	ffjtResponseUserResult
)

var ffjKeyResponseUserOK = []byte("ok")

var ffjKeyResponseUserResult = []byte("result")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ResponseUser) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ResponseUser) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtResponseUserbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtResponseUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'o':

					if bytes.Equal(ffjKeyResponseUserOK, kn) {
						currentKey = ffjtResponseUserOK
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyResponseUserResult, kn) {
						currentKey = ffjtResponseUserResult
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyResponseUserResult, kn) {
					currentKey = ffjtResponseUserResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyResponseUserOK, kn) {
					currentKey = ffjtResponseUserOK
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtResponseUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtResponseUserOK:
					goto handle_OK

				case ffjtResponseUserResult:
					goto handle_Result

				case ffjtResponseUsernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_OK:

	/* handler: j.OK type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.OK = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.OK = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Result:

	/* handler: j.Result type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Result = nil

		} else {

			if j.Result == nil {
				j.Result = new(User)
			}

			err = j.Result.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ShippingAddress) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ShippingAddress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"country_code":`)
	fflib.WriteJsonString(buf, string(j.CountryCode))
	buf.WriteString(`,"state":`)
	fflib.WriteJsonString(buf, string(j.State))
	buf.WriteString(`,"city":`)
	fflib.WriteJsonString(buf, string(j.City))
	buf.WriteString(`,"street_line1":`)
	fflib.WriteJsonString(buf, string(j.StreetLine1))
	buf.WriteString(`,"street_line2":`)
	fflib.WriteJsonString(buf, string(j.StreetLine2))
	buf.WriteString(`,"post_code":`)
	fflib.WriteJsonString(buf, string(j.PostCode))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtShippingAddressbase = iota
	ffjtShippingAddressnosuchkey

	ffjtShippingAddressCountryCode

	ffjtShippingAddressState

	ffjtShippingAddressCity

	ffjtShippingAddressStreetLine1

	ffjtShippingAddressStreetLine2

	ffjtShippingAddressPostCode
)

var ffjKeyShippingAddressCountryCode = []byte("country_code")

var ffjKeyShippingAddressState = []byte("state")

var ffjKeyShippingAddressCity = []byte("city")

var ffjKeyShippingAddressStreetLine1 = []byte("street_line1")

var ffjKeyShippingAddressStreetLine2 = []byte("street_line2")

var ffjKeyShippingAddressPostCode = []byte("post_code")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ShippingAddress) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ShippingAddress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtShippingAddressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtShippingAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyShippingAddressCountryCode, kn) {
						currentKey = ffjtShippingAddressCountryCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingAddressCity, kn) {
						currentKey = ffjtShippingAddressCity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyShippingAddressPostCode, kn) {
						currentKey = ffjtShippingAddressPostCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyShippingAddressState, kn) {
						currentKey = ffjtShippingAddressState
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingAddressStreetLine1, kn) {
						currentKey = ffjtShippingAddressStreetLine1
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingAddressStreetLine2, kn) {
						currentKey = ffjtShippingAddressStreetLine2
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressPostCode, kn) {
					currentKey = ffjtShippingAddressPostCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressStreetLine2, kn) {
					currentKey = ffjtShippingAddressStreetLine2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressStreetLine1, kn) {
					currentKey = ffjtShippingAddressStreetLine1
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingAddressCity, kn) {
					currentKey = ffjtShippingAddressCity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyShippingAddressState, kn) {
					currentKey = ffjtShippingAddressState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShippingAddressCountryCode, kn) {
					currentKey = ffjtShippingAddressCountryCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtShippingAddressnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtShippingAddressCountryCode:
					goto handle_CountryCode

				case ffjtShippingAddressState:
					goto handle_State

				case ffjtShippingAddressCity:
					goto handle_City

				case ffjtShippingAddressStreetLine1:
					goto handle_StreetLine1

				case ffjtShippingAddressStreetLine2:
					goto handle_StreetLine2

				case ffjtShippingAddressPostCode:
					goto handle_PostCode

				case ffjtShippingAddressnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CountryCode:

	/* handler: j.CountryCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CountryCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: j.State type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.State = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_City:

	/* handler: j.City type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.City = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StreetLine1:

	/* handler: j.StreetLine1 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StreetLine1 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StreetLine2:

	/* handler: j.StreetLine2 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StreetLine2 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PostCode:

	/* handler: j.PostCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PostCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ShippingQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ShippingQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteString(`,"invoice_payload":`)
	fflib.WriteJsonString(buf, string(j.InvoicePayload))
	if j.ShippingAddress != nil {
		buf.WriteString(`,"shipping_address":`)

		{

			err = j.ShippingAddress.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"shipping_address":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtShippingQuerybase = iota
	ffjtShippingQuerynosuchkey

	ffjtShippingQueryID

	ffjtShippingQueryFrom

	ffjtShippingQueryInvoicePayload

	ffjtShippingQueryShippingAddress
)

var ffjKeyShippingQueryID = []byte("id")

var ffjKeyShippingQueryFrom = []byte("from")

var ffjKeyShippingQueryInvoicePayload = []byte("invoice_payload")

var ffjKeyShippingQueryShippingAddress = []byte("shipping_address")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ShippingQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ShippingQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtShippingQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtShippingQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyShippingQueryFrom, kn) {
						currentKey = ffjtShippingQueryFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyShippingQueryID, kn) {
						currentKey = ffjtShippingQueryID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyShippingQueryInvoicePayload, kn) {
						currentKey = ffjtShippingQueryInvoicePayload
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyShippingQueryShippingAddress, kn) {
						currentKey = ffjtShippingQueryShippingAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyShippingQueryShippingAddress, kn) {
					currentKey = ffjtShippingQueryShippingAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyShippingQueryInvoicePayload, kn) {
					currentKey = ffjtShippingQueryInvoicePayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingQueryFrom, kn) {
					currentKey = ffjtShippingQueryFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyShippingQueryID, kn) {
					currentKey = ffjtShippingQueryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtShippingQuerynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtShippingQueryID:
					goto handle_ID

				case ffjtShippingQueryFrom:
					goto handle_From

				case ffjtShippingQueryInvoicePayload:
					goto handle_InvoicePayload

				case ffjtShippingQueryShippingAddress:
					goto handle_ShippingAddress

				case ffjtShippingQuerynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=model.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvoicePayload:

	/* handler: j.InvoicePayload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InvoicePayload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingAddress:

	/* handler: j.ShippingAddress type=model.ShippingAddress kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ShippingAddress = nil

		} else {

			if j.ShippingAddress == nil {
				j.ShippingAddress = new(ShippingAddress)
			}

			err = j.ShippingAddress.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Sticker) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Sticker) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	if j.IsAnimated {
		buf.WriteString(`,"is_animated":true`)
	} else {
		buf.WriteString(`,"is_animated":false`)
	}
	if j.IsVideo {
		buf.WriteString(`,"is_video":true`)
	} else {
		buf.WriteString(`,"is_video":false`)
	}
	buf.WriteByte(',')
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Emoji) != 0 {
		buf.WriteString(`"emoji":`)
		fflib.WriteJsonString(buf, string(j.Emoji))
		buf.WriteByte(',')
	}
	if len(j.SetName) != 0 {
		buf.WriteString(`"set_name":`)
		fflib.WriteJsonString(buf, string(j.SetName))
		buf.WriteByte(',')
	}
	if j.PremiumAnimation != nil {
		if true {
			buf.WriteString(`"premium_animation":`)

			{

				err = j.PremiumAnimation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.MaskPosition != nil {
		if true {
			buf.WriteString(`"mask_position":`)

			{

				err = j.MaskPosition.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.CustomEmojiID) != 0 {
		buf.WriteString(`"custom_emoji_id":`)
		fflib.WriteJsonString(buf, string(j.CustomEmojiID))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtStickerbase = iota
	ffjtStickernosuchkey

	ffjtStickerFileID

	ffjtStickerFileUniqueID

	ffjtStickerType

	ffjtStickerWidth

	ffjtStickerHeight

	ffjtStickerIsAnimated

	ffjtStickerIsVideo

	ffjtStickerThumb

	ffjtStickerEmoji

	ffjtStickerSetName

	ffjtStickerPremiumAnimation

	ffjtStickerMaskPosition

	ffjtStickerCustomEmojiID

	ffjtStickerFileSize
)

var ffjKeyStickerFileID = []byte("file_id")

var ffjKeyStickerFileUniqueID = []byte("file_unique_id")

var ffjKeyStickerType = []byte("type")

var ffjKeyStickerWidth = []byte("width")

var ffjKeyStickerHeight = []byte("height")

var ffjKeyStickerIsAnimated = []byte("is_animated")

var ffjKeyStickerIsVideo = []byte("is_video")

var ffjKeyStickerThumb = []byte("thumb")

var ffjKeyStickerEmoji = []byte("emoji")

var ffjKeyStickerSetName = []byte("set_name")

var ffjKeyStickerPremiumAnimation = []byte("premium_animation")

var ffjKeyStickerMaskPosition = []byte("mask_position")

var ffjKeyStickerCustomEmojiID = []byte("custom_emoji_id")

var ffjKeyStickerFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Sticker) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Sticker) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtStickerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyStickerCustomEmojiID, kn) {
						currentKey = ffjtStickerCustomEmojiID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyStickerEmoji, kn) {
						currentKey = ffjtStickerEmoji
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyStickerFileID, kn) {
						currentKey = ffjtStickerFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStickerFileUniqueID, kn) {
						currentKey = ffjtStickerFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStickerFileSize, kn) {
						currentKey = ffjtStickerFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyStickerHeight, kn) {
						currentKey = ffjtStickerHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyStickerIsAnimated, kn) {
						currentKey = ffjtStickerIsAnimated
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStickerIsVideo, kn) {
						currentKey = ffjtStickerIsVideo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyStickerMaskPosition, kn) {
						currentKey = ffjtStickerMaskPosition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyStickerPremiumAnimation, kn) {
						currentKey = ffjtStickerPremiumAnimation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyStickerSetName, kn) {
						currentKey = ffjtStickerSetName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyStickerType, kn) {
						currentKey = ffjtStickerType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStickerThumb, kn) {
						currentKey = ffjtStickerThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyStickerWidth, kn) {
						currentKey = ffjtStickerWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyStickerFileSize, kn) {
					currentKey = ffjtStickerFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerCustomEmojiID, kn) {
					currentKey = ffjtStickerCustomEmojiID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerMaskPosition, kn) {
					currentKey = ffjtStickerMaskPosition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyStickerPremiumAnimation, kn) {
					currentKey = ffjtStickerPremiumAnimation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerSetName, kn) {
					currentKey = ffjtStickerSetName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerEmoji, kn) {
					currentKey = ffjtStickerEmoji
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerThumb, kn) {
					currentKey = ffjtStickerThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerIsVideo, kn) {
					currentKey = ffjtStickerIsVideo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyStickerIsAnimated, kn) {
					currentKey = ffjtStickerIsAnimated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerHeight, kn) {
					currentKey = ffjtStickerHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerWidth, kn) {
					currentKey = ffjtStickerWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerType, kn) {
					currentKey = ffjtStickerType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyStickerFileUniqueID, kn) {
					currentKey = ffjtStickerFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyStickerFileID, kn) {
					currentKey = ffjtStickerFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtStickerFileID:
					goto handle_FileID

				case ffjtStickerFileUniqueID:
					goto handle_FileUniqueID

				case ffjtStickerType:
					goto handle_Type

				case ffjtStickerWidth:
					goto handle_Width

				case ffjtStickerHeight:
					goto handle_Height

				case ffjtStickerIsAnimated:
					goto handle_IsAnimated

				case ffjtStickerIsVideo:
					goto handle_IsVideo

				case ffjtStickerThumb:
					goto handle_Thumb

				case ffjtStickerEmoji:
					goto handle_Emoji

				case ffjtStickerSetName:
					goto handle_SetName

				case ffjtStickerPremiumAnimation:
					goto handle_PremiumAnimation

				case ffjtStickerMaskPosition:
					goto handle_MaskPosition

				case ffjtStickerCustomEmojiID:
					goto handle_CustomEmojiID

				case ffjtStickerFileSize:
					goto handle_FileSize

				case ffjtStickernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsAnimated:

	/* handler: j.IsAnimated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsAnimated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsAnimated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsVideo:

	/* handler: j.IsVideo type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsVideo = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsVideo = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=model.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emoji:

	/* handler: j.Emoji type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Emoji = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SetName:

	/* handler: j.SetName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SetName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PremiumAnimation:

	/* handler: j.PremiumAnimation type=model.File kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PremiumAnimation = nil

		} else {

			if j.PremiumAnimation == nil {
				j.PremiumAnimation = new(File)
			}

			err = j.PremiumAnimation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaskPosition:

	/* handler: j.MaskPosition type=model.MaskPosition kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.MaskPosition = nil

		} else {

			if j.MaskPosition == nil {
				j.MaskPosition = new(MaskPosition)
			}

			err = j.MaskPosition.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CustomEmojiID:

	/* handler: j.CustomEmojiID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CustomEmojiID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SuccessfulPayment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SuccessfulPayment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"total_amount":`)
	fflib.FormatBits2(buf, uint64(j.TotalAmount), 10, j.TotalAmount < 0)
	buf.WriteString(`,"invoice_payload":`)
	fflib.WriteJsonString(buf, string(j.InvoicePayload))
	buf.WriteByte(',')
	if len(j.ShippingOptionID) != 0 {
		buf.WriteString(`"shipping_option_id":`)
		fflib.WriteJsonString(buf, string(j.ShippingOptionID))
		buf.WriteByte(',')
	}
	if j.OrderInfo != nil {
		if true {
			buf.WriteString(`"order_info":`)

			{

				err = j.OrderInfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"telegram_payment_charge_id":`)
	fflib.WriteJsonString(buf, string(j.TelegramPaymentChargeID))
	buf.WriteString(`,"provider_payment_charge_id":`)
	fflib.WriteJsonString(buf, string(j.ProviderPaymentChargeID))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSuccessfulPaymentbase = iota
	ffjtSuccessfulPaymentnosuchkey

	ffjtSuccessfulPaymentCurrency

	ffjtSuccessfulPaymentTotalAmount

	ffjtSuccessfulPaymentInvoicePayload

	ffjtSuccessfulPaymentShippingOptionID

	ffjtSuccessfulPaymentOrderInfo

	ffjtSuccessfulPaymentTelegramPaymentChargeID

	ffjtSuccessfulPaymentProviderPaymentChargeID
)

var ffjKeySuccessfulPaymentCurrency = []byte("currency")

var ffjKeySuccessfulPaymentTotalAmount = []byte("total_amount")

var ffjKeySuccessfulPaymentInvoicePayload = []byte("invoice_payload")

var ffjKeySuccessfulPaymentShippingOptionID = []byte("shipping_option_id")

var ffjKeySuccessfulPaymentOrderInfo = []byte("order_info")

var ffjKeySuccessfulPaymentTelegramPaymentChargeID = []byte("telegram_payment_charge_id")

var ffjKeySuccessfulPaymentProviderPaymentChargeID = []byte("provider_payment_charge_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SuccessfulPayment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SuccessfulPayment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSuccessfulPaymentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSuccessfulPaymentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeySuccessfulPaymentCurrency, kn) {
						currentKey = ffjtSuccessfulPaymentCurrency
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeySuccessfulPaymentInvoicePayload, kn) {
						currentKey = ffjtSuccessfulPaymentInvoicePayload
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeySuccessfulPaymentOrderInfo, kn) {
						currentKey = ffjtSuccessfulPaymentOrderInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeySuccessfulPaymentProviderPaymentChargeID, kn) {
						currentKey = ffjtSuccessfulPaymentProviderPaymentChargeID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeySuccessfulPaymentShippingOptionID, kn) {
						currentKey = ffjtSuccessfulPaymentShippingOptionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeySuccessfulPaymentTotalAmount, kn) {
						currentKey = ffjtSuccessfulPaymentTotalAmount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySuccessfulPaymentTelegramPaymentChargeID, kn) {
						currentKey = ffjtSuccessfulPaymentTelegramPaymentChargeID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentProviderPaymentChargeID, kn) {
					currentKey = ffjtSuccessfulPaymentProviderPaymentChargeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentTelegramPaymentChargeID, kn) {
					currentKey = ffjtSuccessfulPaymentTelegramPaymentChargeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentOrderInfo, kn) {
					currentKey = ffjtSuccessfulPaymentOrderInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySuccessfulPaymentShippingOptionID, kn) {
					currentKey = ffjtSuccessfulPaymentShippingOptionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentInvoicePayload, kn) {
					currentKey = ffjtSuccessfulPaymentInvoicePayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeySuccessfulPaymentTotalAmount, kn) {
					currentKey = ffjtSuccessfulPaymentTotalAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySuccessfulPaymentCurrency, kn) {
					currentKey = ffjtSuccessfulPaymentCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSuccessfulPaymentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSuccessfulPaymentCurrency:
					goto handle_Currency

				case ffjtSuccessfulPaymentTotalAmount:
					goto handle_TotalAmount

				case ffjtSuccessfulPaymentInvoicePayload:
					goto handle_InvoicePayload

				case ffjtSuccessfulPaymentShippingOptionID:
					goto handle_ShippingOptionID

				case ffjtSuccessfulPaymentOrderInfo:
					goto handle_OrderInfo

				case ffjtSuccessfulPaymentTelegramPaymentChargeID:
					goto handle_TelegramPaymentChargeID

				case ffjtSuccessfulPaymentProviderPaymentChargeID:
					goto handle_ProviderPaymentChargeID

				case ffjtSuccessfulPaymentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalAmount:

	/* handler: j.TotalAmount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalAmount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvoicePayload:

	/* handler: j.InvoicePayload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InvoicePayload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingOptionID:

	/* handler: j.ShippingOptionID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShippingOptionID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OrderInfo:

	/* handler: j.OrderInfo type=model.OrderInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.OrderInfo = nil

		} else {

			if j.OrderInfo == nil {
				j.OrderInfo = new(OrderInfo)
			}

			err = j.OrderInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramPaymentChargeID:

	/* handler: j.TelegramPaymentChargeID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TelegramPaymentChargeID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProviderPaymentChargeID:

	/* handler: j.ProviderPaymentChargeID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProviderPaymentChargeID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Update) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Update) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "update_id":`)
	fflib.FormatBits2(buf, uint64(j.UpdateID), 10, j.UpdateID < 0)
	buf.WriteByte(',')
	if j.Message != nil {
		if true {
			buf.WriteString(`"message":`)

			{

				err = j.Message.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.EditedMessage != nil {
		if true {
			buf.WriteString(`"edited_message":`)

			{

				err = j.EditedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ChannelPost != nil {
		if true {
			buf.WriteString(`"channel_post":`)

			{

				err = j.ChannelPost.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.EditedChannelPost != nil {
		if true {
			buf.WriteString(`"edited_channel_post":`)

			{

				err = j.EditedChannelPost.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.InlineQuery != nil {
		if true {
			buf.WriteString(`"inline_query":`)

			{

				err = j.InlineQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ChosenInlineResult != nil {
		if true {
			buf.WriteString(`"chosen_inline_result":`)

			{

				err = j.ChosenInlineResult.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.CallbackQuery != nil {
		if true {
			buf.WriteString(`"callback_query":`)

			{

				err = j.CallbackQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ShippingQuery != nil {
		if true {
			buf.WriteString(`"shipping_query":`)

			{

				err = j.ShippingQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.PreCheckoutQuery != nil {
		if true {
			buf.WriteString(`"pre_checkout_query":`)

			{

				err = j.PreCheckoutQuery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Poll != nil {
		if true {
			buf.WriteString(`"poll":`)

			{

				err = j.Poll.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.PollAnswer != nil {
		if true {
			buf.WriteString(`"poll_answer":`)

			{

				err = j.PollAnswer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.MyChatMember != nil {
		if true {
			buf.WriteString(`"my_chat_member":`)

			{

				err = j.MyChatMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ChatMember != nil {
		if true {
			buf.WriteString(`"chat_member":`)

			{

				err = j.ChatMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.ChatJoinRequest != nil {
		if true {
			buf.WriteString(`"chat_join_request":`)

			{

				err = j.ChatJoinRequest.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUpdatebase = iota
	ffjtUpdatenosuchkey

	ffjtUpdateUpdateID

	ffjtUpdateMessage

	ffjtUpdateEditedMessage

	ffjtUpdateChannelPost

	ffjtUpdateEditedChannelPost

	ffjtUpdateInlineQuery

	ffjtUpdateChosenInlineResult

	ffjtUpdateCallbackQuery

	ffjtUpdateShippingQuery

	ffjtUpdatePreCheckoutQuery

	ffjtUpdatePoll

	ffjtUpdatePollAnswer

	ffjtUpdateMyChatMember

	ffjtUpdateChatMember

	ffjtUpdateChatJoinRequest
)

var ffjKeyUpdateUpdateID = []byte("update_id")

var ffjKeyUpdateMessage = []byte("message")

var ffjKeyUpdateEditedMessage = []byte("edited_message")

var ffjKeyUpdateChannelPost = []byte("channel_post")

var ffjKeyUpdateEditedChannelPost = []byte("edited_channel_post")

var ffjKeyUpdateInlineQuery = []byte("inline_query")

var ffjKeyUpdateChosenInlineResult = []byte("chosen_inline_result")

var ffjKeyUpdateCallbackQuery = []byte("callback_query")

var ffjKeyUpdateShippingQuery = []byte("shipping_query")

var ffjKeyUpdatePreCheckoutQuery = []byte("pre_checkout_query")

var ffjKeyUpdatePoll = []byte("poll")

var ffjKeyUpdatePollAnswer = []byte("poll_answer")

var ffjKeyUpdateMyChatMember = []byte("my_chat_member")

var ffjKeyUpdateChatMember = []byte("chat_member")

var ffjKeyUpdateChatJoinRequest = []byte("chat_join_request")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Update) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Update) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUpdatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyUpdateChannelPost, kn) {
						currentKey = ffjtUpdateChannelPost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateChosenInlineResult, kn) {
						currentKey = ffjtUpdateChosenInlineResult
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateCallbackQuery, kn) {
						currentKey = ffjtUpdateCallbackQuery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateChatMember, kn) {
						currentKey = ffjtUpdateChatMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateChatJoinRequest, kn) {
						currentKey = ffjtUpdateChatJoinRequest
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyUpdateEditedMessage, kn) {
						currentKey = ffjtUpdateEditedMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateEditedChannelPost, kn) {
						currentKey = ffjtUpdateEditedChannelPost
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUpdateInlineQuery, kn) {
						currentKey = ffjtUpdateInlineQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyUpdateMessage, kn) {
						currentKey = ffjtUpdateMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdateMyChatMember, kn) {
						currentKey = ffjtUpdateMyChatMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyUpdatePreCheckoutQuery, kn) {
						currentKey = ffjtUpdatePreCheckoutQuery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdatePoll, kn) {
						currentKey = ffjtUpdatePoll
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUpdatePollAnswer, kn) {
						currentKey = ffjtUpdatePollAnswer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUpdateShippingQuery, kn) {
						currentKey = ffjtUpdateShippingQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyUpdateUpdateID, kn) {
						currentKey = ffjtUpdateUpdateID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUpdateChatJoinRequest, kn) {
					currentKey = ffjtUpdateChatJoinRequest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateChatMember, kn) {
					currentKey = ffjtUpdateChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateMyChatMember, kn) {
					currentKey = ffjtUpdateMyChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdatePollAnswer, kn) {
					currentKey = ffjtUpdatePollAnswer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUpdatePoll, kn) {
					currentKey = ffjtUpdatePoll
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdatePreCheckoutQuery, kn) {
					currentKey = ffjtUpdatePreCheckoutQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateShippingQuery, kn) {
					currentKey = ffjtUpdateShippingQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateCallbackQuery, kn) {
					currentKey = ffjtUpdateCallbackQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateChosenInlineResult, kn) {
					currentKey = ffjtUpdateChosenInlineResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateInlineQuery, kn) {
					currentKey = ffjtUpdateInlineQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateEditedChannelPost, kn) {
					currentKey = ffjtUpdateEditedChannelPost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateChannelPost, kn) {
					currentKey = ffjtUpdateChannelPost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateEditedMessage, kn) {
					currentKey = ffjtUpdateEditedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUpdateMessage, kn) {
					currentKey = ffjtUpdateMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUpdateUpdateID, kn) {
					currentKey = ffjtUpdateUpdateID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUpdatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUpdateUpdateID:
					goto handle_UpdateID

				case ffjtUpdateMessage:
					goto handle_Message

				case ffjtUpdateEditedMessage:
					goto handle_EditedMessage

				case ffjtUpdateChannelPost:
					goto handle_ChannelPost

				case ffjtUpdateEditedChannelPost:
					goto handle_EditedChannelPost

				case ffjtUpdateInlineQuery:
					goto handle_InlineQuery

				case ffjtUpdateChosenInlineResult:
					goto handle_ChosenInlineResult

				case ffjtUpdateCallbackQuery:
					goto handle_CallbackQuery

				case ffjtUpdateShippingQuery:
					goto handle_ShippingQuery

				case ffjtUpdatePreCheckoutQuery:
					goto handle_PreCheckoutQuery

				case ffjtUpdatePoll:
					goto handle_Poll

				case ffjtUpdatePollAnswer:
					goto handle_PollAnswer

				case ffjtUpdateMyChatMember:
					goto handle_MyChatMember

				case ffjtUpdateChatMember:
					goto handle_ChatMember

				case ffjtUpdateChatJoinRequest:
					goto handle_ChatJoinRequest

				case ffjtUpdatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UpdateID:

	/* handler: j.UpdateID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UpdateID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: j.Message type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Message = nil

		} else {

			if j.Message == nil {
				j.Message = new(Message)
			}

			err = j.Message.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedMessage:

	/* handler: j.EditedMessage type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.EditedMessage = nil

		} else {

			if j.EditedMessage == nil {
				j.EditedMessage = new(Message)
			}

			err = j.EditedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelPost:

	/* handler: j.ChannelPost type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ChannelPost = nil

		} else {

			if j.ChannelPost == nil {
				j.ChannelPost = new(Message)
			}

			err = j.ChannelPost.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedChannelPost:

	/* handler: j.EditedChannelPost type=model.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.EditedChannelPost = nil

		} else {

			if j.EditedChannelPost == nil {
				j.EditedChannelPost = new(Message)
			}

			err = j.EditedChannelPost.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineQuery:

	/* handler: j.InlineQuery type=model.InlineQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.InlineQuery = nil

		} else {

			if j.InlineQuery == nil {
				j.InlineQuery = new(InlineQuery)
			}

			err = j.InlineQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChosenInlineResult:

	/* handler: j.ChosenInlineResult type=model.ChosenInlineResult kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ChosenInlineResult = nil

		} else {

			if j.ChosenInlineResult == nil {
				j.ChosenInlineResult = new(ChosenInlineResult)
			}

			err = j.ChosenInlineResult.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackQuery:

	/* handler: j.CallbackQuery type=model.CallbackQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CallbackQuery = nil

		} else {

			if j.CallbackQuery == nil {
				j.CallbackQuery = new(CallbackQuery)
			}

			err = j.CallbackQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShippingQuery:

	/* handler: j.ShippingQuery type=model.ShippingQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ShippingQuery = nil

		} else {

			if j.ShippingQuery == nil {
				j.ShippingQuery = new(ShippingQuery)
			}

			err = j.ShippingQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreCheckoutQuery:

	/* handler: j.PreCheckoutQuery type=model.PreCheckoutQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PreCheckoutQuery = nil

		} else {

			if j.PreCheckoutQuery == nil {
				j.PreCheckoutQuery = new(PreCheckoutQuery)
			}

			err = j.PreCheckoutQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Poll:

	/* handler: j.Poll type=model.Poll kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Poll = nil

		} else {

			if j.Poll == nil {
				j.Poll = new(Poll)
			}

			err = j.Poll.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PollAnswer:

	/* handler: j.PollAnswer type=model.PollAnswer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PollAnswer = nil

		} else {

			if j.PollAnswer == nil {
				j.PollAnswer = new(PollAnswer)
			}

			err = j.PollAnswer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MyChatMember:

	/* handler: j.MyChatMember type=model.ChatMemberUpdated kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.MyChatMember = nil

		} else {

			if j.MyChatMember == nil {
				j.MyChatMember = new(ChatMemberUpdated)
			}

			err = j.MyChatMember.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatMember:

	/* handler: j.ChatMember type=model.ChatMemberUpdated kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ChatMember = nil

		} else {

			if j.ChatMember == nil {
				j.ChatMember = new(ChatMemberUpdated)
			}

			err = j.ChatMember.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatJoinRequest:

	/* handler: j.ChatJoinRequest type=model.ChatJoinRequest kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ChatJoinRequest = nil

		} else {

			if j.ChatJoinRequest == nil {
				j.ChatJoinRequest = new(ChatJoinRequest)
			}

			err = j.ChatJoinRequest.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *User) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *User) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	if j.IsBot {
		buf.WriteString(`,"is_bot":true`)
	} else {
		buf.WriteString(`,"is_bot":false`)
	}
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if len(j.Username) != 0 {
		buf.WriteString(`"username":`)
		fflib.WriteJsonString(buf, string(j.Username))
		buf.WriteByte(',')
	}
	if len(j.LanguageCode) != 0 {
		buf.WriteString(`"language_code":`)
		fflib.WriteJsonString(buf, string(j.LanguageCode))
		buf.WriteByte(',')
	}
	if j.IsPremium != false {
		if j.IsPremium {
			buf.WriteString(`"is_premium":true`)
		} else {
			buf.WriteString(`"is_premium":false`)
		}
		buf.WriteByte(',')
	}
	if j.AddedToAttachmentMenu != false {
		if j.AddedToAttachmentMenu {
			buf.WriteString(`"added_to_attachment_menu":true`)
		} else {
			buf.WriteString(`"added_to_attachment_menu":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanJoinGroups != false {
		if j.CanJoinGroups {
			buf.WriteString(`"can_join_groups":true`)
		} else {
			buf.WriteString(`"can_join_groups":false`)
		}
		buf.WriteByte(',')
	}
	if j.CanReadAllGroupMessages != false {
		if j.CanReadAllGroupMessages {
			buf.WriteString(`"can_read_all_group_messages":true`)
		} else {
			buf.WriteString(`"can_read_all_group_messages":false`)
		}
		buf.WriteByte(',')
	}
	if j.SupportInlineQueries != false {
		if j.SupportInlineQueries {
			buf.WriteString(`"support_inline_queries":true`)
		} else {
			buf.WriteString(`"support_inline_queries":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserbase = iota
	ffjtUsernosuchkey

	ffjtUserID

	ffjtUserIsBot

	ffjtUserFirstName

	ffjtUserLastName

	ffjtUserUsername

	ffjtUserLanguageCode

	ffjtUserIsPremium

	ffjtUserAddedToAttachmentMenu

	ffjtUserCanJoinGroups

	ffjtUserCanReadAllGroupMessages

	ffjtUserSupportInlineQueries
)

var ffjKeyUserID = []byte("id")

var ffjKeyUserIsBot = []byte("is_bot")

var ffjKeyUserFirstName = []byte("first_name")

var ffjKeyUserLastName = []byte("last_name")

var ffjKeyUserUsername = []byte("username")

var ffjKeyUserLanguageCode = []byte("language_code")

var ffjKeyUserIsPremium = []byte("is_premium")

var ffjKeyUserAddedToAttachmentMenu = []byte("added_to_attachment_menu")

var ffjKeyUserCanJoinGroups = []byte("can_join_groups")

var ffjKeyUserCanReadAllGroupMessages = []byte("can_read_all_group_messages")

var ffjKeyUserSupportInlineQueries = []byte("support_inline_queries")

// UnmarshalJSON umarshall json - template of ffjson
func (j *User) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *User) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyUserAddedToAttachmentMenu, kn) {
						currentKey = ffjtUserAddedToAttachmentMenu
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyUserCanJoinGroups, kn) {
						currentKey = ffjtUserCanJoinGroups
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserCanReadAllGroupMessages, kn) {
						currentKey = ffjtUserCanReadAllGroupMessages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyUserFirstName, kn) {
						currentKey = ffjtUserFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUserID, kn) {
						currentKey = ffjtUserID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserIsBot, kn) {
						currentKey = ffjtUserIsBot
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserIsPremium, kn) {
						currentKey = ffjtUserIsPremium
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyUserLastName, kn) {
						currentKey = ffjtUserLastName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserLanguageCode, kn) {
						currentKey = ffjtUserLanguageCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyUserSupportInlineQueries, kn) {
						currentKey = ffjtUserSupportInlineQueries
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyUserUsername, kn) {
						currentKey = ffjtUserUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUserSupportInlineQueries, kn) {
					currentKey = ffjtUserSupportInlineQueries
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserCanReadAllGroupMessages, kn) {
					currentKey = ffjtUserCanReadAllGroupMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserCanJoinGroups, kn) {
					currentKey = ffjtUserCanJoinGroups
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserAddedToAttachmentMenu, kn) {
					currentKey = ffjtUserAddedToAttachmentMenu
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserIsPremium, kn) {
					currentKey = ffjtUserIsPremium
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserLanguageCode, kn) {
					currentKey = ffjtUserLanguageCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUsername, kn) {
					currentKey = ffjtUserUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserLastName, kn) {
					currentKey = ffjtUserLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserFirstName, kn) {
					currentKey = ffjtUserFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserIsBot, kn) {
					currentKey = ffjtUserIsBot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserID, kn) {
					currentKey = ffjtUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserID:
					goto handle_ID

				case ffjtUserIsBot:
					goto handle_IsBot

				case ffjtUserFirstName:
					goto handle_FirstName

				case ffjtUserLastName:
					goto handle_LastName

				case ffjtUserUsername:
					goto handle_Username

				case ffjtUserLanguageCode:
					goto handle_LanguageCode

				case ffjtUserIsPremium:
					goto handle_IsPremium

				case ffjtUserAddedToAttachmentMenu:
					goto handle_AddedToAttachmentMenu

				case ffjtUserCanJoinGroups:
					goto handle_CanJoinGroups

				case ffjtUserCanReadAllGroupMessages:
					goto handle_CanReadAllGroupMessages

				case ffjtUserSupportInlineQueries:
					goto handle_SupportInlineQueries

				case ffjtUsernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsBot:

	/* handler: j.IsBot type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsBot = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsBot = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: j.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LanguageCode:

	/* handler: j.LanguageCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LanguageCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsPremium:

	/* handler: j.IsPremium type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsPremium = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsPremium = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AddedToAttachmentMenu:

	/* handler: j.AddedToAttachmentMenu type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AddedToAttachmentMenu = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AddedToAttachmentMenu = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanJoinGroups:

	/* handler: j.CanJoinGroups type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanJoinGroups = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanJoinGroups = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CanReadAllGroupMessages:

	/* handler: j.CanReadAllGroupMessages type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CanReadAllGroupMessages = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CanReadAllGroupMessages = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SupportInlineQueries:

	/* handler: j.SupportInlineQueries type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SupportInlineQueries = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SupportInlineQueries = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Venue) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Venue) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Location != nil {
		buf.WriteString(`{ "location":`)

		{

			err = j.Location.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{ "location":null`)
	}
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte(',')
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	if len(j.FoursquareType) != 0 {
		buf.WriteString(`"foursquare_type":`)
		fflib.WriteJsonString(buf, string(j.FoursquareType))
		buf.WriteByte(',')
	}
	if len(j.GooglePlaceID) != 0 {
		buf.WriteString(`"google_place_id":`)
		fflib.WriteJsonString(buf, string(j.GooglePlaceID))
		buf.WriteByte(',')
	}
	if len(j.GooglePlaceType) != 0 {
		buf.WriteString(`"google_place_type":`)
		fflib.WriteJsonString(buf, string(j.GooglePlaceType))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVenuebase = iota
	ffjtVenuenosuchkey

	ffjtVenueLocation

	ffjtVenueTitle

	ffjtVenueAddress

	ffjtVenueFoursquareID

	ffjtVenueFoursquareType

	ffjtVenueGooglePlaceID

	ffjtVenueGooglePlaceType
)

var ffjKeyVenueLocation = []byte("location")

var ffjKeyVenueTitle = []byte("title")

var ffjKeyVenueAddress = []byte("address")

var ffjKeyVenueFoursquareID = []byte("foursquare_id")

var ffjKeyVenueFoursquareType = []byte("foursquare_type")

var ffjKeyVenueGooglePlaceID = []byte("google_place_id")

var ffjKeyVenueGooglePlaceType = []byte("google_place_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Venue) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Venue) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVenuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyVenueAddress, kn) {
						currentKey = ffjtVenueAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVenueFoursquareID, kn) {
						currentKey = ffjtVenueFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVenueFoursquareType, kn) {
						currentKey = ffjtVenueFoursquareType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyVenueGooglePlaceID, kn) {
						currentKey = ffjtVenueGooglePlaceID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVenueGooglePlaceType, kn) {
						currentKey = ffjtVenueGooglePlaceType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyVenueLocation, kn) {
						currentKey = ffjtVenueLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVenueTitle, kn) {
						currentKey = ffjtVenueTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyVenueGooglePlaceType, kn) {
					currentKey = ffjtVenueGooglePlaceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVenueGooglePlaceID, kn) {
					currentKey = ffjtVenueGooglePlaceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVenueFoursquareType, kn) {
					currentKey = ffjtVenueFoursquareType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVenueFoursquareID, kn) {
					currentKey = ffjtVenueFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVenueAddress, kn) {
					currentKey = ffjtVenueAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVenueTitle, kn) {
					currentKey = ffjtVenueTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVenueLocation, kn) {
					currentKey = ffjtVenueLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVenueLocation:
					goto handle_Location

				case ffjtVenueTitle:
					goto handle_Title

				case ffjtVenueAddress:
					goto handle_Address

				case ffjtVenueFoursquareID:
					goto handle_FoursquareID

				case ffjtVenueFoursquareType:
					goto handle_FoursquareType

				case ffjtVenueGooglePlaceID:
					goto handle_GooglePlaceID

				case ffjtVenueGooglePlaceType:
					goto handle_GooglePlaceType

				case ffjtVenuenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Location:

	/* handler: j.Location type=model.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareType:

	/* handler: j.FoursquareType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GooglePlaceID:

	/* handler: j.GooglePlaceID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GooglePlaceID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GooglePlaceType:

	/* handler: j.GooglePlaceType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GooglePlaceType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Video) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Video) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(j.FileName))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideobase = iota
	ffjtVideonosuchkey

	ffjtVideoFileID

	ffjtVideoFileUniqueID

	ffjtVideoWidth

	ffjtVideoHeight

	ffjtVideoDuration

	ffjtVideoThumb

	ffjtVideoFileName

	ffjtVideoMimeType

	ffjtVideoFileSize
)

var ffjKeyVideoFileID = []byte("file_id")

var ffjKeyVideoFileUniqueID = []byte("file_unique_id")

var ffjKeyVideoWidth = []byte("width")

var ffjKeyVideoHeight = []byte("height")

var ffjKeyVideoDuration = []byte("duration")

var ffjKeyVideoThumb = []byte("thumb")

var ffjKeyVideoFileName = []byte("file_name")

var ffjKeyVideoMimeType = []byte("mime_type")

var ffjKeyVideoFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Video) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Video) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVideoDuration, kn) {
						currentKey = ffjtVideoDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVideoFileID, kn) {
						currentKey = ffjtVideoFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoFileUniqueID, kn) {
						currentKey = ffjtVideoFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoFileName, kn) {
						currentKey = ffjtVideoFileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoFileSize, kn) {
						currentKey = ffjtVideoFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyVideoHeight, kn) {
						currentKey = ffjtVideoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyVideoMimeType, kn) {
						currentKey = ffjtVideoMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVideoThumb, kn) {
						currentKey = ffjtVideoThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyVideoWidth, kn) {
						currentKey = ffjtVideoWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVideoFileSize, kn) {
					currentKey = ffjtVideoFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoMimeType, kn) {
					currentKey = ffjtVideoMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoFileName, kn) {
					currentKey = ffjtVideoFileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoThumb, kn) {
					currentKey = ffjtVideoThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoDuration, kn) {
					currentKey = ffjtVideoDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoHeight, kn) {
					currentKey = ffjtVideoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoWidth, kn) {
					currentKey = ffjtVideoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoFileUniqueID, kn) {
					currentKey = ffjtVideoFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoFileID, kn) {
					currentKey = ffjtVideoFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoFileID:
					goto handle_FileID

				case ffjtVideoFileUniqueID:
					goto handle_FileUniqueID

				case ffjtVideoWidth:
					goto handle_Width

				case ffjtVideoHeight:
					goto handle_Height

				case ffjtVideoDuration:
					goto handle_Duration

				case ffjtVideoThumb:
					goto handle_Thumb

				case ffjtVideoFileName:
					goto handle_FileName

				case ffjtVideoMimeType:
					goto handle_MimeType

				case ffjtVideoFileSize:
					goto handle_FileSize

				case ffjtVideonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=model.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: j.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VideoChatEnded) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VideoChatEnded) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideoChatEndedbase = iota
	ffjtVideoChatEndednosuchkey

	ffjtVideoChatEndedDuration
)

var ffjKeyVideoChatEndedDuration = []byte("duration")

// UnmarshalJSON umarshall json - template of ffjson
func (j *VideoChatEnded) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VideoChatEnded) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideoChatEndedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideoChatEndednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVideoChatEndedDuration, kn) {
						currentKey = ffjtVideoChatEndedDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoChatEndedDuration, kn) {
					currentKey = ffjtVideoChatEndedDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideoChatEndednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoChatEndedDuration:
					goto handle_Duration

				case ffjtVideoChatEndednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VideoChatParticipantsInvited) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VideoChatParticipantsInvited) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"users":`)
	if j.Users != nil {
		buf.WriteString(`[`)
		for i, v := range j.Users {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				if v == nil {
					buf.WriteString("null")
				} else {

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideoChatParticipantsInvitedbase = iota
	ffjtVideoChatParticipantsInvitednosuchkey

	ffjtVideoChatParticipantsInvitedUsers
)

var ffjKeyVideoChatParticipantsInvitedUsers = []byte("users")

// UnmarshalJSON umarshall json - template of ffjson
func (j *VideoChatParticipantsInvited) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VideoChatParticipantsInvited) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideoChatParticipantsInvitedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideoChatParticipantsInvitednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'u':

					if bytes.Equal(ffjKeyVideoChatParticipantsInvitedUsers, kn) {
						currentKey = ffjtVideoChatParticipantsInvitedUsers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVideoChatParticipantsInvitedUsers, kn) {
					currentKey = ffjtVideoChatParticipantsInvitedUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideoChatParticipantsInvitednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoChatParticipantsInvitedUsers:
					goto handle_Users

				case ffjtVideoChatParticipantsInvitednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Users:

	/* handler: j.Users type=[]*model.User kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Users = nil
		} else {

			j.Users = []*User{}

			wantVal := true

			for {

				var tmpJUsers *User

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJUsers type=*model.User kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJUsers = nil

					} else {

						if tmpJUsers == nil {
							tmpJUsers = new(User)
						}

						err = tmpJUsers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Users = append(j.Users, tmpJUsers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VideoChatScheduled) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VideoChatScheduled) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"start_date":`)
	fflib.FormatBits2(buf, uint64(j.StartDate), 10, j.StartDate < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideoChatScheduledbase = iota
	ffjtVideoChatSchedulednosuchkey

	ffjtVideoChatScheduledStartDate
)

var ffjKeyVideoChatScheduledStartDate = []byte("start_date")

// UnmarshalJSON umarshall json - template of ffjson
func (j *VideoChatScheduled) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VideoChatScheduled) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideoChatScheduledbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideoChatSchedulednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffjKeyVideoChatScheduledStartDate, kn) {
						currentKey = ffjtVideoChatScheduledStartDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVideoChatScheduledStartDate, kn) {
					currentKey = ffjtVideoChatScheduledStartDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideoChatSchedulednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoChatScheduledStartDate:
					goto handle_StartDate

				case ffjtVideoChatSchedulednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_StartDate:

	/* handler: j.StartDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StartDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VideoChatStarted) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VideoChatStarted) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffjtVideoChatStartedbase = iota
	ffjtVideoChatStartednosuchkey
)

// UnmarshalJSON umarshall json - template of ffjson
func (j *VideoChatStarted) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VideoChatStarted) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideoChatStartedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideoChatStartednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffjtVideoChatStartednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoChatStartednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *VideoNote) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *VideoNote) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"length":`)
	fflib.FormatBits2(buf, uint64(j.Length), 10, j.Length < 0)
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.Thumb != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumb.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideoNotebase = iota
	ffjtVideoNotenosuchkey

	ffjtVideoNoteFileID

	ffjtVideoNoteFileUniqueID

	ffjtVideoNoteLength

	ffjtVideoNoteDuration

	ffjtVideoNoteThumb

	ffjtVideoNoteFileSize
)

var ffjKeyVideoNoteFileID = []byte("file_id")

var ffjKeyVideoNoteFileUniqueID = []byte("file_unique_id")

var ffjKeyVideoNoteLength = []byte("length")

var ffjKeyVideoNoteDuration = []byte("duration")

var ffjKeyVideoNoteThumb = []byte("thumb")

var ffjKeyVideoNoteFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *VideoNote) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *VideoNote) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideoNotebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideoNotenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVideoNoteDuration, kn) {
						currentKey = ffjtVideoNoteDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVideoNoteFileID, kn) {
						currentKey = ffjtVideoNoteFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoNoteFileUniqueID, kn) {
						currentKey = ffjtVideoNoteFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoNoteFileSize, kn) {
						currentKey = ffjtVideoNoteFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyVideoNoteLength, kn) {
						currentKey = ffjtVideoNoteLength
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVideoNoteThumb, kn) {
						currentKey = ffjtVideoNoteThumb
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVideoNoteFileSize, kn) {
					currentKey = ffjtVideoNoteFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoNoteThumb, kn) {
					currentKey = ffjtVideoNoteThumb
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoNoteDuration, kn) {
					currentKey = ffjtVideoNoteDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoNoteLength, kn) {
					currentKey = ffjtVideoNoteLength
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoNoteFileUniqueID, kn) {
					currentKey = ffjtVideoNoteFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoNoteFileID, kn) {
					currentKey = ffjtVideoNoteFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideoNotenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoNoteFileID:
					goto handle_FileID

				case ffjtVideoNoteFileUniqueID:
					goto handle_FileUniqueID

				case ffjtVideoNoteLength:
					goto handle_Length

				case ffjtVideoNoteDuration:
					goto handle_Duration

				case ffjtVideoNoteThumb:
					goto handle_Thumb

				case ffjtVideoNoteFileSize:
					goto handle_FileSize

				case ffjtVideoNotenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Length:

	/* handler: j.Length type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Length = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumb:

	/* handler: j.Thumb type=model.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumb = nil

		} else {

			if j.Thumb == nil {
				j.Thumb = new(PhotoSize)
			}

			err = j.Thumb.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Voice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Voice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"file_unique_id":`)
	fflib.WriteJsonString(buf, string(j.FileUniqueID))
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVoicebase = iota
	ffjtVoicenosuchkey

	ffjtVoiceFileID

	ffjtVoiceFileUniqueID

	ffjtVoiceDuration

	ffjtVoiceMimeType

	ffjtVoiceFileSize
)

var ffjKeyVoiceFileID = []byte("file_id")

var ffjKeyVoiceFileUniqueID = []byte("file_unique_id")

var ffjKeyVoiceDuration = []byte("duration")

var ffjKeyVoiceMimeType = []byte("mime_type")

var ffjKeyVoiceFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Voice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Voice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVoiceDuration, kn) {
						currentKey = ffjtVoiceDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVoiceFileID, kn) {
						currentKey = ffjtVoiceFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceFileUniqueID, kn) {
						currentKey = ffjtVoiceFileUniqueID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceFileSize, kn) {
						currentKey = ffjtVoiceFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyVoiceMimeType, kn) {
						currentKey = ffjtVoiceMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVoiceFileSize, kn) {
					currentKey = ffjtVoiceFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceMimeType, kn) {
					currentKey = ffjtVoiceMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVoiceDuration, kn) {
					currentKey = ffjtVoiceDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceFileUniqueID, kn) {
					currentKey = ffjtVoiceFileUniqueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceFileID, kn) {
					currentKey = ffjtVoiceFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVoiceFileID:
					goto handle_FileID

				case ffjtVoiceFileUniqueID:
					goto handle_FileUniqueID

				case ffjtVoiceDuration:
					goto handle_Duration

				case ffjtVoiceMimeType:
					goto handle_MimeType

				case ffjtVoiceFileSize:
					goto handle_FileSize

				case ffjtVoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileUniqueID:

	/* handler: j.FileUniqueID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileUniqueID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *WebAppData) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *WebAppData) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"data":`)
	fflib.WriteJsonString(buf, string(j.Data))
	buf.WriteString(`,"button_text":`)
	fflib.WriteJsonString(buf, string(j.ButtonText))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtWebAppDatabase = iota
	ffjtWebAppDatanosuchkey

	ffjtWebAppDataData

	ffjtWebAppDataButtonText
)

var ffjKeyWebAppDataData = []byte("data")

var ffjKeyWebAppDataButtonText = []byte("button_text")

// UnmarshalJSON umarshall json - template of ffjson
func (j *WebAppData) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *WebAppData) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtWebAppDatabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtWebAppDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyWebAppDataButtonText, kn) {
						currentKey = ffjtWebAppDataButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyWebAppDataData, kn) {
						currentKey = ffjtWebAppDataData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyWebAppDataButtonText, kn) {
					currentKey = ffjtWebAppDataButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyWebAppDataData, kn) {
					currentKey = ffjtWebAppDataData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtWebAppDatanosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtWebAppDataData:
					goto handle_Data

				case ffjtWebAppDataButtonText:
					goto handle_ButtonText

				case ffjtWebAppDatanosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Data:

	/* handler: j.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ButtonText:

	/* handler: j.ButtonText type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ButtonText = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *WebAppInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *WebAppInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtWebAppInfobase = iota
	ffjtWebAppInfonosuchkey

	ffjtWebAppInfoURL
)

var ffjKeyWebAppInfoURL = []byte("url")

// UnmarshalJSON umarshall json - template of ffjson
func (j *WebAppInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *WebAppInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtWebAppInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtWebAppInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'u':

					if bytes.Equal(ffjKeyWebAppInfoURL, kn) {
						currentKey = ffjtWebAppInfoURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyWebAppInfoURL, kn) {
					currentKey = ffjtWebAppInfoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtWebAppInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtWebAppInfoURL:
					goto handle_URL

				case ffjtWebAppInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
